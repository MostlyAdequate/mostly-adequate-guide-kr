
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Chapter 08: Tupperware · Professor Frisby's Mostly Adequate Guide to Functional Programming</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-exercises/exercises.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ch08.html" />
    
    
    <link rel="prev" href="ch07-kr.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="ch01-kr.html">
            
                <a href="ch01-kr.html">
            
                    
                    01 장: 우리는 무엇을 하고 있나?
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="ch01-kr.html">
            
                <a href="ch01-kr.html#소개">
            
                    
                    소개
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="ch01-kr.html">
            
                <a href="ch01-kr.html#짧은-만남">
            
                    
                    짧은 만남
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="ch02-kr.html">
            
                <a href="ch02-kr.html">
            
                    
                    02 장: 일급 함수
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="ch02-kr.html">
            
                <a href="ch02-kr.html#복습-시간">
            
                    
                    복습 시간
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="ch02-kr.html">
            
                <a href="ch02-kr.html#일급-함수의-장점">
            
                    
                    일급 함수의 장점
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="ch03-kr.html">
            
                <a href="ch03-kr.html">
            
                    
                    03 장: 순수 함수와 순수한 기쁨을
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="ch03-kr.html">
            
                <a href="ch03-kr.html#한번-더-순수함에-대하여">
            
                    
                    한번 더 순수함에 대하여
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="ch03-kr.html">
            
                <a href="ch03-kr.html#부수효과는-를-포함할-수-있어요">
            
                    
                    부수효과는 ...를 포함할 수 있어요
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="ch03-kr.html">
            
                <a href="ch03-kr.html#중학교-2학년-수학">
            
                    
                    중학교 2학년 수학
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="ch03-kr.html">
            
                <a href="ch03-kr.html#순수성의-예">
            
                    
                    순수성의 예
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="ch03-kr.html">
            
                <a href="ch03-kr.html#요약">
            
                    
                    요약
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="ch04-kr.html">
            
                <a href="ch04-kr.html">
            
                    
                    04 장: 커링
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="ch04-kr.html">
            
                <a href="ch04-kr.html#cant-live-if-livin-is-without-you">
            
                    
                    Can't Live If Livin' Is without You
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="ch04-kr.html">
            
                <a href="ch04-kr.html#말장난-조금-더--특별한-소스">
            
                    
                    말장난 조금 더 / 특별한 소스
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="ch04.md-kr">
            
                <span>
            
                    
                    요약
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="ch04.md-kr">
            
                <span>
            
                    
                    연습문제
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="ch05.html">
            
                <a href="ch05.html">
            
                    
                    Chapter 05: Coding by Composing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="ch05.html">
            
                <a href="ch05.html#functional-husbandry">
            
                    
                    Functional Husbandry
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="ch05.html">
            
                <a href="ch05.html#pointfree">
            
                    
                    Pointfree
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="ch05.html">
            
                <a href="ch05.html#debugging">
            
                    
                    Debugging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="ch05.html">
            
                <a href="ch05.html#category-theory">
            
                    
                    Category Theory
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="ch05.html">
            
                <a href="ch05.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="ch05.html">
            
                <a href="ch05.html#exercises">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="ch06.html">
            
                <a href="ch06.html">
            
                    
                    Chapter 06: Example Application
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="ch06.html">
            
                <a href="ch06.html#declarative-coding">
            
                    
                    Declarative Coding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="ch06.html">
            
                <a href="ch06.html#a-flickr-of-functional-programming">
            
                    
                    A Flickr of Functional Programming
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="ch06.html">
            
                <a href="ch06.html#a-principled-refactor">
            
                    
                    A Principled Refactor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="ch06.html">
            
                <a href="ch06.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html">
            
                    
                    07 장: 힌들리-밀너와 나
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html#당신은-무슨-타입인가요">
            
                    
                    당신은 무슨 타입인가요?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html#비밀-이야기">
            
                    
                    비밀 이야기
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html#가능성을-높이기">
            
                    
                    가능성을 높이기
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html#공짜로-정리-얻기">
            
                    
                    공짜로 정리 얻기
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html#제약">
            
                    
                    제약
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.6" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html#요약">
            
                    
                    요약
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter active" data-level="1.9" data-path="ch08.html">
            
                <a href="ch08.html">
            
                    
                    Chapter 08: Tupperware
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="ch08.html">
            
                <a href="ch08.html#the-mighty-container">
            
                    
                    The Mighty Container
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="ch08.html">
            
                <a href="ch08.html#my-first-functor">
            
                    
                    My First Functor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="ch08.html">
            
                <a href="ch08.html#schrödingers-maybe">
            
                    
                    Schrödinger's Maybe
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="ch08.html">
            
                <a href="ch08.html#use-cases">
            
                    
                    Use Cases
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="ch08.html">
            
                <a href="ch08.html#releasing-the-value">
            
                    
                    Releasing the Value
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="ch08.html">
            
                <a href="ch08.html#pure-error-handling">
            
                    
                    Pure Error Handling
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="ch08.html">
            
                <a href="ch08.html#old-mcdonald-had-effects">
            
                    
                    Old McDonald Had Effects...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.8" data-path="ch08.html">
            
                <a href="ch08.html#asynchronous-tasks">
            
                    
                    Asynchronous Tasks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.9" data-path="ch08.html">
            
                <a href="ch08.html#a-spot-of-theory">
            
                    
                    A Spot of Theory
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.10" data-path="ch08.html">
            
                <a href="ch08.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.11" data-path="ch08.html">
            
                <a href="ch08.html#exercises">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="ch09.html">
            
                <a href="ch09.html">
            
                    
                    Chapter 09: Monadic Onions
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="ch09.html">
            
                <a href="ch09.html#pointy-functor-factory">
            
                    
                    Pointy Functor Factory
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="ch09.html">
            
                <a href="ch09.html#mixing-metaphors">
            
                    
                    Mixing Metaphors
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="ch09.html">
            
                <a href="ch09.html#my-chain-hits-my-chest">
            
                    
                    My Chain Hits My Chest
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="ch09.html">
            
                <a href="ch09.html#power-trip">
            
                    
                    Power Trip
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="ch09.html">
            
                <a href="ch09.html#theory">
            
                    
                    Theory
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="ch09.html">
            
                <a href="ch09.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="ch09.html">
            
                <a href="ch09.html#exercises">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="ch10.html">
            
                <a href="ch10.html">
            
                    
                    Chapter 10: Applicative Functors
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="ch10.html">
            
                <a href="ch10.html#applying-applicatives">
            
                    
                    Applying Applicatives
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="ch10.html">
            
                <a href="ch10.html#ships-in-bottles">
            
                    
                    Ships in Bottles
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="ch10.html">
            
                <a href="ch10.html#coordination-motivation">
            
                    
                    Coordination Motivation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.4" data-path="ch10.html">
            
                <a href="ch10.html#bro-do-you-even-lift">
            
                    
                    Bro, Do You Even Lift?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.5" data-path="ch10.html">
            
                <a href="ch10.html#operators">
            
                    
                    Operators
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.6" data-path="ch10.html">
            
                <a href="ch10.html#free-can-openers">
            
                    
                    Free Can Openers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.7" data-path="ch10.html">
            
                <a href="ch10.html#laws">
            
                    
                    Laws
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.8" data-path="ch10.html">
            
                <a href="ch10.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.9" data-path="ch10.html">
            
                <a href="ch10.html#exercises">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="ch11.html">
            
                <a href="ch11.html">
            
                    
                    Chapter 11: Transform Again, Naturally
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="ch11.html">
            
                <a href="ch11.html#curse-this-nest">
            
                    
                    Curse This Nest
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="ch11.html">
            
                <a href="ch11.html#a-situational-comedy">
            
                    
                    A Situational Comedy
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="ch11.html">
            
                <a href="ch11.html#all-natural">
            
                    
                    All Natural
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.4" data-path="ch11.html">
            
                <a href="ch11.html#principled-type-conversions">
            
                    
                    Principled Type Conversions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.5" data-path="ch11.html">
            
                <a href="ch11.html#feature-envy">
            
                    
                    Feature Envy
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.6" data-path="ch11.html">
            
                <a href="ch11.html#isomorphic-javascript">
            
                    
                    Isomorphic JavaScript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.7" data-path="ch11.html">
            
                <a href="ch11.html#a-broader-definition">
            
                    
                    A Broader Definition
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.8" data-path="ch11.html">
            
                <a href="ch11.html#one-nesting-solution">
            
                    
                    One Nesting Solution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.9" data-path="ch11.html">
            
                <a href="ch11.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.10" data-path="ch11.html">
            
                <a href="ch11.html#exercises">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="ch12.html">
            
                <a href="ch12.html">
            
                    
                    Chapter 12: Traversing the Stone
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.1" data-path="ch12.html">
            
                <a href="ch12.html#types-n-types">
            
                    
                    Types n' Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2" data-path="ch12.html">
            
                <a href="ch12.html#type-feng-shui">
            
                    
                    Type Feng Shui
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.3" data-path="ch12.html">
            
                <a href="ch12.html#effect-assortment">
            
                    
                    Effect Assortment
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.4" data-path="ch12.html">
            
                <a href="ch12.html#waltz-of-the-types">
            
                    
                    Waltz of the Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.5" data-path="ch12.html">
            
                <a href="ch12.html#no-law-and-order">
            
                    
                    No Law and Order
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.6" data-path="ch12.html">
            
                <a href="ch12.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.7" data-path="ch12.html">
            
                <a href="ch12.html#exercises">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="appendix_a.html">
            
                <a href="appendix_a.html">
            
                    
                    Appendix A: Essential Functions Support
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" data-path="appendix_a.html">
            
                <a href="appendix_a.html#always">
            
                    
                    always
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2" data-path="appendix_a.html">
            
                <a href="appendix_a.html#compose">
            
                    
                    compose
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.3" data-path="appendix_a.html">
            
                <a href="appendix_a.html#curry">
            
                    
                    curry
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.4" data-path="appendix_a.html">
            
                <a href="appendix_a.html#either">
            
                    
                    either
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.5" data-path="appendix_a.html">
            
                <a href="appendix_a.html#identity">
            
                    
                    identity
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.6" data-path="appendix_a.html">
            
                <a href="appendix_a.html#inspect">
            
                    
                    inspect
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.7" data-path="appendix_a.html">
            
                <a href="appendix_a.html#left">
            
                    
                    left
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.8" data-path="appendix_a.html">
            
                <a href="appendix_a.html#lifta">
            
                    
                    liftA*
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.9" data-path="appendix_a.html">
            
                <a href="appendix_a.html#maybe">
            
                    
                    maybe
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.10" data-path="appendix_a.html">
            
                <a href="appendix_a.html#nothing">
            
                    
                    nothing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.11" data-path="appendix_a.html">
            
                <a href="appendix_a.html#reject">
            
                    
                    reject
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="appendix_b.html">
            
                <a href="appendix_b.html">
            
                    
                    Appendix B: Algebraic Structures Support
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="appendix_b.html">
            
                <a href="appendix_b.html#compose">
            
                    
                    Compose
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.2" data-path="appendix_b.html">
            
                <a href="appendix_b.html#either">
            
                    
                    Either
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.3" data-path="appendix_b.html">
            
                <a href="appendix_b.html#identity">
            
                    
                    Identity
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.4" data-path="appendix_b.html">
            
                <a href="appendix_b.html#io">
            
                    
                    IO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5" data-path="appendix_b.html">
            
                <a href="appendix_b.html#list">
            
                    
                    List
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.6" data-path="appendix_b.html">
            
                <a href="appendix_b.html#map">
            
                    
                    Map
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.7" data-path="appendix_b.html">
            
                <a href="appendix_b.html#maybe">
            
                    
                    Maybe
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8" data-path="appendix_b.html">
            
                <a href="appendix_b.html#task">
            
                    
                    Task
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="appendix_c.html">
            
                <a href="appendix_c.html">
            
                    
                    Appendix C: Pointfree Utilities
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="appendix_c.html">
            
                <a href="appendix_c.html#add">
            
                    
                    add
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.2" data-path="appendix_c.html">
            
                <a href="appendix_c.html#append">
            
                    
                    append
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3" data-path="appendix_c.html">
            
                <a href="appendix_c.html#chain">
            
                    
                    chain
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.4" data-path="appendix_c.html">
            
                <a href="appendix_c.html#concat">
            
                    
                    concat
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.5" data-path="appendix_c.html">
            
                <a href="appendix_c.html#eq">
            
                    
                    eq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.6" data-path="appendix_c.html">
            
                <a href="appendix_c.html#filter">
            
                    
                    filter
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.7" data-path="appendix_c.html">
            
                <a href="appendix_c.html#flip">
            
                    
                    flip
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.8" data-path="appendix_c.html">
            
                <a href="appendix_c.html#foreach">
            
                    
                    forEach
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.9" data-path="appendix_c.html">
            
                <a href="appendix_c.html#head">
            
                    
                    head
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.10" data-path="appendix_c.html">
            
                <a href="appendix_c.html#intercalate">
            
                    
                    intercalate
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.11" data-path="appendix_c.html">
            
                <a href="appendix_c.html#join">
            
                    
                    join
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.12" data-path="appendix_c.html">
            
                <a href="appendix_c.html#last">
            
                    
                    last
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.13" data-path="appendix_c.html">
            
                <a href="appendix_c.html#map">
            
                    
                    map
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.14" data-path="appendix_c.html">
            
                <a href="appendix_c.html#match">
            
                    
                    match
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.15" data-path="appendix_c.html">
            
                <a href="appendix_c.html#prop">
            
                    
                    prop
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.16" data-path="appendix_c.html">
            
                <a href="appendix_c.html#reduce">
            
                    
                    reduce
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.17" data-path="appendix_c.html">
            
                <a href="appendix_c.html#replace">
            
                    
                    replace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.18" data-path="appendix_c.html">
            
                <a href="appendix_c.html#safehead">
            
                    
                    safeHead
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.19" data-path="appendix_c.html">
            
                <a href="appendix_c.html#safelast">
            
                    
                    safeLast
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.20" data-path="appendix_c.html">
            
                <a href="appendix_c.html#safeprop">
            
                    
                    safeProp
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.21" data-path="appendix_c.html">
            
                <a href="appendix_c.html#sequence">
            
                    
                    sequence
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.22" data-path="appendix_c.html">
            
                <a href="appendix_c.html#sortby">
            
                    
                    sortBy
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.23" data-path="appendix_c.html">
            
                <a href="appendix_c.html#split">
            
                    
                    split
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.24" data-path="appendix_c.html">
            
                <a href="appendix_c.html#take">
            
                    
                    take
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.25" data-path="appendix_c.html">
            
                <a href="appendix_c.html#tolowercase">
            
                    
                    toLowerCase
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.26" data-path="appendix_c.html">
            
                <a href="appendix_c.html#tostring">
            
                    
                    toString
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.27" data-path="appendix_c.html">
            
                <a href="appendix_c.html#touppercase">
            
                    
                    toUpperCase
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.28" data-path="appendix_c.html">
            
                <a href="appendix_c.html#traverse">
            
                    
                    traverse
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.29" data-path="appendix_c.html">
            
                <a href="appendix_c.html#unsafeperformio">
            
                    
                    unsafePerformIO
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Chapter 08: Tupperware</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="chapter-08-tupperware">Chapter 08: Tupperware</h1>
<h2 id="the-mighty-container">The Mighty Container</h2>
<p><img src="images/jar.jpg" alt="http://blog.dwinegar.com/2011/06/another-jar.html"></p>
<p>We&apos;ve seen how to write programs which pipe data through a series of pure functions. They are declarative specifications of behaviour. But what about control flow, error handling, asynchronous actions, state and, dare I say, effects?! In this chapter, we will discover the foundation upon which all of these helpful abstractions are built.</p>
<p>First we will create a container. This container must hold any type of value; a ziplock that holds only tapioca pudding is rarely useful. It will be an object, but we will not give it properties and methods in the OO sense. No, we will treat it like a treasure chest - a special box that cradles our valuable data.</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> </span>{
  <span class="hljs-keyword">constructor</span>(x) {
    <span class="hljs-keyword">this</span>.$value = x;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(x) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Container(x);
  }
}
</code></pre>
<p>Here is our first container. We&apos;ve thoughtfully named it <code>Container</code>. We will use <code>Container.of</code> as a constructor which saves us from having to write that awful <code>new</code> keyword all over the place. There&apos;s more to the <code>of</code> function than meets the eye, but for now, think of it as the proper way to place values into our container.</p>
<p>Let&apos;s examine our brand new box...</p>
<pre><code class="lang-js">Container.of(<span class="hljs-number">3</span>);
<span class="hljs-comment">// Container(3)</span>

Container.of(<span class="hljs-string">&apos;hotdogs&apos;</span>);
<span class="hljs-comment">// Container(&quot;hotdogs&quot;)</span>

Container.of(Container.of({ name: <span class="hljs-string">&apos;yoda&apos;</span> }));
<span class="hljs-comment">// Container(Container({ name: &apos;yoda&apos; }))</span>
</code></pre>
<p>If you are using node, you will see <code>{$value: x}</code> even though we&apos;ve got ourselves a <code>Container(x)</code>. Chrome will output the type properly, but no matter; as long as we understand what a <code>Container</code> looks like, we&apos;ll be fine. In some environments you can overwrite the <code>inspect</code> method if you&apos;d like, but we will not be so thorough. For this book, we will write the conceptual output as if we&apos;d overwritten <code>inspect</code> as it&apos;s much more instructive than <code>{$value: x}</code> for pedagogical as well as aesthetic reasons.</p>
<p>Let&apos;s make a few things clear before we move on:</p>
<ul>
<li><p><code>Container</code> is an object with one property. Lots of containers just hold one thing, though they aren&apos;t limited to one. We&apos;ve arbitrarily named its property <code>$value</code>.</p>
</li>
<li><p>The <code>$value</code> cannot be one specific type or our <code>Container</code> would hardly live up to the name.</p>
</li>
<li><p>Once data goes into the <code>Container</code> it stays there. We <em>could</em> get it out by using <code>.$value</code>, but that would defeat the purpose.</p>
</li>
</ul>
<p>The reasons we&apos;re doing this will become clear as a mason jar, but for now, bear with me.</p>
<h2 id="my-first-functor">My First Functor</h2>
<p>Once our value, whatever it may be, is in the container, we&apos;ll need a way to run functions on it.</p>
<pre><code class="lang-js"><span class="hljs-comment">// (a -&gt; b) -&gt; Container a -&gt; Container b</span>
Container.prototype.map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{
  <span class="hljs-keyword">return</span> Container.of(f(<span class="hljs-keyword">this</span>.$value));
};
</code></pre>
<p>Why, it&apos;s just like Array&apos;s famous <code>map</code>, except we have <code>Container a</code> instead of <code>[a]</code>. And it works essentially the same way:</p>
<pre><code class="lang-js">Container.of(<span class="hljs-number">2</span>).map(two =&gt; two + <span class="hljs-number">2</span>); 
<span class="hljs-comment">// Container(4)</span>

Container.of(<span class="hljs-string">&apos;flamethrowers&apos;</span>).map(s =&gt; s.toUpperCase()); 
<span class="hljs-comment">// Container(&apos;FLAMETHROWERS&apos;)</span>

Container.of(<span class="hljs-string">&apos;bombs&apos;</span>).map(append(<span class="hljs-string">&apos; away&apos;</span>)).map(prop(<span class="hljs-string">&apos;length&apos;</span>)); 
<span class="hljs-comment">// Container(10)</span>
</code></pre>
<p>We can work with our value without ever having to leave the <code>Container</code>. This is a remarkable thing. Our value in the <code>Container</code> is handed to the <code>map</code> function so we can fuss with it and afterward, returned to its <code>Container</code> for safe keeping. As a result of never leaving the <code>Container</code>, we can continue to <code>map</code> away, running functions as we please. We can even change the type as we go along as demonstrated in the latter of the three examples.</p>
<p>Wait a minute, if we keep calling <code>map</code>, it appears to be some sort of composition! What mathematical magic is at work here? Well chaps, we&apos;ve just discovered <em>Functors</em>.</p>
<blockquote>
<p>A Functor is a type that implements <code>map</code> and obeys some laws</p>
</blockquote>
<p>Yes, <em>Functor</em> is simply an interface with a contract. We could have just as easily named it <em>Mappable</em>, but now, where&apos;s the <em>fun</em> in that? Functors come from category theory and we&apos;ll look at the maths in detail toward the end of the chapter, but for now, let&apos;s work on intuition and practical uses for this bizarrely named interface.</p>
<p>What reason could we possibly have for bottling up a value and using <code>map</code> to get at it? The answer reveals itself if we choose a better question: What do we gain from asking our container to apply functions for us? Well, abstraction of function application. When we <code>map</code> a function, we ask the container type to run it for us. This is a very powerful concept, indeed.</p>
<h2 id="schr&#xF6;dingers-maybe">Schr&#xF6;dinger&apos;s Maybe</h2>
<p><img src="images/cat.png" alt="cool cat, need reference"></p>
<p><code>Container</code> is fairly boring. In fact, it is usually called <code>Identity</code> and has about the same impact as our <code>id</code> function (again there is a mathematical connection we&apos;ll look at when the time is right). However, there are other functors, that is, container-like types that have a proper <code>map</code> function, which can provide useful behaviour whilst mapping. Let&apos;s define one now.</p>
<blockquote>
<p>A complete implementation is given in the <a href="appendix_b.html#Maybe">Appendix B</a></p>
</blockquote>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maybe</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(x) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Maybe(x);
  }

  get isNothing() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$value === <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span>.$value === <span class="hljs-literal">undefined</span>;
  }

  <span class="hljs-keyword">constructor</span>(x) {
    <span class="hljs-keyword">this</span>.$value = x;
  }

  map(fn) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNothing ? <span class="hljs-keyword">this</span> : Maybe.of(fn(<span class="hljs-keyword">this</span>.$value));
  }

  inspect() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNothing ? <span class="hljs-string">&apos;Nothing&apos;</span> : <span class="hljs-string">`Just(<span class="hljs-subst">${inspect(this.$value)}</span>)`</span>;
  }
}
</code></pre>
<p>Now, <code>Maybe</code> looks a lot like <code>Container</code> with one minor change: it will first check to see if it has a value before calling the supplied function. This has the effect of side stepping those pesky nulls as we <code>map</code>(Note that this implementation is simplified for teaching).</p>
<pre><code class="lang-js">Maybe.of(<span class="hljs-string">&apos;Malkovich Malkovich&apos;</span>).map(match(<span class="hljs-regexp">/a/ig</span>));
<span class="hljs-comment">// Just(True)</span>

Maybe.of(<span class="hljs-literal">null</span>).map(match(<span class="hljs-regexp">/a/ig</span>));
<span class="hljs-comment">// Nothing</span>

Maybe.of({ name: <span class="hljs-string">&apos;Boris&apos;</span> }).map(prop(<span class="hljs-string">&apos;age&apos;</span>)).map(add(<span class="hljs-number">10</span>));
<span class="hljs-comment">// Nothing</span>

Maybe.of({ name: <span class="hljs-string">&apos;Dinah&apos;</span>, age: <span class="hljs-number">14</span> }).map(prop(<span class="hljs-string">&apos;age&apos;</span>)).map(add(<span class="hljs-number">10</span>));
<span class="hljs-comment">// Just(24)</span>
</code></pre>
<p>Notice our app doesn&apos;t explode with errors as we map functions over our null values. This is because <code>Maybe</code> will take care to check for a value each and every time it applies a function.</p>
<p>This dot syntax is perfectly fine and functional, but for reasons mentioned in Part 1, we&apos;d like to maintain our pointfree style. As it happens, <code>map</code> is fully equipped to delegate to whatever functor it receives:</p>
<pre><code class="lang-js"><span class="hljs-comment">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span>
<span class="hljs-keyword">const</span> map = curry((f, anyFunctor) =&gt; anyFunctor.map(f));
</code></pre>
<p>This is delightful as we can carry on with composition per usual and <code>map</code> will work as expected. This is the case with ramda&apos;s <code>map</code> as well. We&apos;ll use dot notation when it&apos;s instructive and the pointfree version when it&apos;s convenient. Did you notice that? I&apos;ve sneakily introduced extra notation into our type signature. The <code>Functor f =&gt;</code> tells us that <code>f</code> must be a Functor. Not that difficult, but I felt I should mention it.</p>
<h2 id="use-cases">Use Cases</h2>
<p>In the wild, we&apos;ll typically see <code>Maybe</code> used in functions which might fail to return a result.</p>
<pre><code class="lang-js"><span class="hljs-comment">// safeHead :: [a] -&gt; Maybe(a)</span>
<span class="hljs-keyword">const</span> safeHead = xs =&gt; Maybe.of(xs[<span class="hljs-number">0</span>]);

<span class="hljs-comment">// streetName :: Object -&gt; Maybe String</span>
<span class="hljs-keyword">const</span> streetName = compose(map(prop(<span class="hljs-string">&apos;street&apos;</span>)), safeHead, prop(<span class="hljs-string">&apos;addresses&apos;</span>));

streetName({ addresses: [] });
<span class="hljs-comment">// Nothing</span>

streetName({ addresses: [{ street: <span class="hljs-string">&apos;Shady Ln.&apos;</span>, number: <span class="hljs-number">4201</span> }] });
<span class="hljs-comment">// Just(&apos;Shady Ln.&apos;)</span>
</code></pre>
<p><code>safeHead</code> is like our normal <code>head</code>, but with added type safety. A curious thing happens when <code>Maybe</code> is introduced into our code; we are forced to deal with those sneaky <code>null</code> values. The <code>safeHead</code> function is honest and up front about its possible failure - there&apos;s really nothing to be ashamed of - and so it returns a <code>Maybe</code> to inform us of this matter. We are more than merely <em>informed</em>, however, because we are forced to <code>map</code> to get at the value we want since it is tucked away inside the <code>Maybe</code> object. Essentially, this is a <code>null</code> check enforced by the <code>safeHead</code> function itself. We can now sleep better at night knowing a <code>null</code> value won&apos;t rear its ugly, decapitated head when we least expect it. APIs like this will upgrade a flimsy application from paper and tacks to wood and nails. They will guarantee safer software.</p>
<p>Sometimes a function might return a <code>Nothing</code> explicitly to signal failure. For instance:</p>
<pre><code class="lang-js"><span class="hljs-comment">// withdraw :: Number -&gt; Account -&gt; Maybe(Account)</span>
<span class="hljs-keyword">const</span> withdraw = curry((amount, { balance }) =&gt;
  Maybe.of(balance &gt;= amount ? { balance: balance - amount } : <span class="hljs-literal">null</span>));

<span class="hljs-comment">// This function is hypothetical, not implemented here... nor anywhere else.</span>
<span class="hljs-comment">// updateLedger :: Account -&gt; Account </span>
<span class="hljs-keyword">const</span> updateLedger = account =&gt; account;

<span class="hljs-comment">// remainingBalance :: Account -&gt; String</span>
<span class="hljs-keyword">const</span> remainingBalance = ({ balance }) =&gt; <span class="hljs-string">`Your balance is $<span class="hljs-subst">${balance}</span>`</span>;

<span class="hljs-comment">// finishTransaction :: Account -&gt; String</span>
<span class="hljs-keyword">const</span> finishTransaction = compose(remainingBalance, updateLedger);


<span class="hljs-comment">// getTwenty :: Account -&gt; Maybe(String)</span>
<span class="hljs-keyword">const</span> getTwenty = compose(map(finishTransaction), withdraw(<span class="hljs-number">20</span>));

getTwenty({ balance: <span class="hljs-number">200.00</span> }); 
<span class="hljs-comment">// Just(&apos;Your balance is $180&apos;)</span>

getTwenty({ balance: <span class="hljs-number">10.00</span> });
<span class="hljs-comment">// Nothing</span>
</code></pre>
<p><code>withdraw</code> will tip its nose at us and return <code>Nothing</code> if we&apos;re short on cash. This function also communicates its fickleness and leaves us no choice, but to <code>map</code> everything afterwards. The difference is that the <code>null</code> was intentional here. Instead of a <code>Just(&apos;..&apos;)</code>, we get the <code>Nothing</code> back to signal failure and our application effectively halts in its tracks. This is important to note: if the <code>withdraw</code> fails, then <code>map</code> will sever the rest of our computation since it doesn&apos;t ever run the mapped functions, namely <code>finishTransaction</code>. This is precisely the intended behaviour as we&apos;d prefer not to update our ledger or show a new balance if we hadn&apos;t successfully withdrawn funds.</p>
<h2 id="releasing-the-value">Releasing the Value</h2>
<p>One thing people often miss is that there will always be an end of the line; some effecting function that sends JSON along, or prints to the screen, or alters our filesystem, or what have you. We cannot deliver the output with <code>return</code>, we must run some function or another to send it out into the world. We can phrase it like a Zen Buddhist koan: &quot;If a program has no observable effect, does it even run?&quot;. Does it run correctly for its own satisfaction? I suspect it merely burns some cycles and goes back to sleep...</p>
<p>Our application&apos;s job is to retrieve, transform, and carry that data along until it&apos;s time to say goodbye and the function which does so may be mapped, thus the value needn&apos;t leave the warm womb of its container. Indeed, a common error is to try to remove the value from our <code>Maybe</code> one way or another as if the possible value inside will suddenly materialize and all will be forgiven. We must understand it may be a branch of code where our value is not around to live up to its destiny.  Our code, much like Schr&#xF6;dinger&apos;s cat, is in two states at once and should maintain that fact until the final function. This gives our code a linear flow despite the logical branching.</p>
<p>There is, however, an escape hatch. If we would rather return a custom value and continue on, we can use a little helper called <code>maybe</code>.</p>
<pre><code class="lang-js"><span class="hljs-comment">// maybe :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b</span>
<span class="hljs-keyword">const</span> maybe = curry((v, f, m) =&gt; {
  <span class="hljs-keyword">if</span> (m.isNothing) {
    <span class="hljs-keyword">return</span> v;
  }

  <span class="hljs-keyword">return</span> f(m.$value);
});

<span class="hljs-comment">// getTwenty :: Account -&gt; String</span>
<span class="hljs-keyword">const</span> getTwenty = compose(maybe(<span class="hljs-string">&apos;You\&apos;re broke!&apos;</span>, finishTransaction), withdraw(<span class="hljs-number">20</span>));

getTwenty({ balance: <span class="hljs-number">200.00</span> }); 
<span class="hljs-comment">// &apos;Your balance is $180.00&apos;</span>

getTwenty({ balance: <span class="hljs-number">10.00</span> }); 
<span class="hljs-comment">// &apos;You\&apos;re broke!&apos;</span>
</code></pre>
<p>We will now either return a static value (of the same type that <code>finishTransaction</code> returns) or continue on merrily finishing up the transaction sans <code>Maybe</code>. With <code>maybe</code>, we are witnessing the equivalent of an <code>if/else</code> statement whereas with <code>map</code>, the imperative analog would be: <code>if (x !== null) { return f(x) }</code>.</p>
<p>The introduction of <code>Maybe</code> can cause some initial discomfort. Users of Swift and Scala will know what I mean as it&apos;s baked right into the core libraries under the guise of <code>Option(al)</code>. When pushed to deal with <code>null</code> checks all the time (and there are times we know with absolute certainty the value exists), most people can&apos;t help but feel it&apos;s a tad laborious. However, with time, it will become second nature and you&apos;ll likely appreciate the safety. After all, most of the time it will prevent cut corners and save our hides.</p>
<p>Writing unsafe software is like taking care to paint each egg with pastels before hurling it into traffic; like building a retirement home with materials warned against by three little pigs. It will do us well to put some safety into our functions and <code>Maybe</code> helps us do just that.</p>
<p>I&apos;d be remiss if I didn&apos;t mention that the &quot;real&quot; implementation will split <code>Maybe</code> into two types: one for something and the other for nothing. This allows us to obey parametricity in <code>map</code> so values like <code>null</code> and <code>undefined</code> can still be mapped over and the universal qualification of the value in a functor will be respected. You&apos;ll often see types like <code>Some(x) / None</code> or <code>Just(x) / Nothing</code> instead of a <code>Maybe</code> that does a <code>null</code> check on its value.</p>
<h2 id="pure-error-handling">Pure Error Handling</h2>
<p><img src="images/fists.jpg" alt="pick a hand... need a reference"></p>
<p>It may come as a shock, but <code>throw/catch</code> is not very pure. When an error is thrown, instead of returning an output value, we sound the alarms! The function attacks, spewing thousands of 0s and 1s like shields and spears in an electric battle against our intruding input. With our new friend <code>Either</code>, we can do better than to declare war on input, we can respond with a polite message. Let&apos;s take a look:</p>
<blockquote>
<p>A complete implementation is given in the <a href="appendix_b.html#Either">Appendix B</a></p>
</blockquote>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Either</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(x) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Right(x);
  }

  <span class="hljs-keyword">constructor</span>(x) {
    <span class="hljs-keyword">this</span>.$value = x;
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Left</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Either</span> </span>{
  map(f) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  inspect() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Left(<span class="hljs-subst">${inspect(this.$value)}</span>)`</span>;
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Right</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Either</span> </span>{
  map(f) {
    <span class="hljs-keyword">return</span> Either.of(f(<span class="hljs-keyword">this</span>.$value));
  }

  inspect() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Right(<span class="hljs-subst">${inspect(this.$value)}</span>)`</span>;
  }
}

<span class="hljs-keyword">const</span> left = x =&gt; <span class="hljs-keyword">new</span> Left(x);
</code></pre>
<p><code>Left</code> and <code>Right</code> are two subclasses of an abstract type we call <code>Either</code>. I&apos;ve skipped the ceremony of creating the <code>Either</code> superclass as we won&apos;t ever use it, but it&apos;s good to be aware. Now then, there&apos;s nothing new here besides the two types. Let&apos;s see how they act:</p>
<pre><code class="lang-js">Either.of(<span class="hljs-string">&apos;rain&apos;</span>).map(str =&gt; <span class="hljs-string">`b<span class="hljs-subst">${str}</span>`</span>); 
<span class="hljs-comment">// Right(&apos;brain&apos;)</span>

left(<span class="hljs-string">&apos;rain&apos;</span>).map(str =&gt; <span class="hljs-string">`It&apos;s gonna <span class="hljs-subst">${str}</span>, better bring your umbrella!`</span>); 
<span class="hljs-comment">// Left(&apos;rain&apos;)</span>

Either.of({ host: <span class="hljs-string">&apos;localhost&apos;</span>, port: <span class="hljs-number">80</span> }).map(prop(<span class="hljs-string">&apos;host&apos;</span>));
<span class="hljs-comment">// Right(&apos;localhost&apos;)</span>

left(<span class="hljs-string">&apos;rolls eyes...&apos;</span>).map(prop(<span class="hljs-string">&apos;host&apos;</span>));
<span class="hljs-comment">// Left(&apos;rolls eyes...&apos;)</span>
</code></pre>
<p><code>Left</code> is the teenagery sort and ignores our request to <code>map</code> over it. <code>Right</code> will work just like <code>Container</code> (a.k.a Identity). The power comes from the ability to embed an error message within the <code>Left</code>.</p>
<p>Suppose we have a function that might not succeed. How about we calculate an age from a birth date. We could use <code>Nothing</code> to signal failure and branch our program, however, that doesn&apos;t tell us much. Perhaps, we&apos;d like to know why it failed. Let&apos;s write this using <code>Either</code>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> moment = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;moment&apos;</span>);

<span class="hljs-comment">// getAge :: Date -&gt; User -&gt; Either(String, Number)</span>
<span class="hljs-keyword">const</span> getAge = curry((now, user) =&gt; {
  <span class="hljs-keyword">const</span> birthDate = moment(user.birthDate, <span class="hljs-string">&apos;YYYY-MM-DD&apos;</span>);

  <span class="hljs-keyword">return</span> birthDate.isValid()
    ? Either.of(now.diff(birthDate, <span class="hljs-string">&apos;years&apos;</span>))
    : left(<span class="hljs-string">&apos;Birth date could not be parsed&apos;</span>);
});

getAge(moment(), { birthDate: <span class="hljs-string">&apos;2005-12-12&apos;</span> });
<span class="hljs-comment">// Right(9)</span>

getAge(moment(), { birthDate: <span class="hljs-string">&apos;July 4, 2001&apos;</span> });
<span class="hljs-comment">// Left(&apos;Birth date could not be parsed&apos;)</span>
</code></pre>
<p>Now, just like <code>Nothing</code>, we are short-circuiting our app when we return a <code>Left</code>. The difference, is now we have a clue as to why our program has derailed. Something to notice is that we return <code>Either(String, Number)</code>, which holds a <code>String</code> as its left value and a <code>Number</code> as its <code>Right</code>. This type signature is a bit informal as we haven&apos;t taken the time to define an actual <code>Either</code> superclass, however, we learn a lot from the type. It informs us that we&apos;re either getting an error message or the age back.</p>
<pre><code class="lang-js"><span class="hljs-comment">// fortune :: Number -&gt; String</span>
<span class="hljs-keyword">const</span> fortune = compose(concat(<span class="hljs-string">&apos;If you survive, you will be &apos;</span>), toString, add(<span class="hljs-number">1</span>));

<span class="hljs-comment">// zoltar :: User -&gt; Either(String, _)</span>
<span class="hljs-keyword">const</span> zoltar = compose(map(<span class="hljs-built_in">console</span>.log), map(fortune), getAge(moment()));

zoltar({ birthDate: <span class="hljs-string">&apos;2005-12-12&apos;</span> });
<span class="hljs-comment">// &apos;If you survive, you will be 10&apos;</span>
<span class="hljs-comment">// Right(undefined)</span>

zoltar({ birthDate: <span class="hljs-string">&apos;balloons!&apos;</span> });
<span class="hljs-comment">// Left(&apos;Birth date could not be parsed&apos;)</span>
</code></pre>
<p>When the <code>birthDate</code> is valid, the program outputs its mystical fortune to the screen for us to behold. Otherwise, we are handed a <code>Left</code> with the error message plain as day though still tucked away in its container. That acts just as if we&apos;d thrown an error, but in a calm, mild manner fashion as opposed to losing its temper and screaming like a child when something goes wrong.</p>
<p>In this example, we are logically branching our control flow depending on the validity of the birth date, yet it reads as one linear motion from right to left rather than climbing through the curly braces of a conditional statement. Usually, we&apos;d move the <code>console.log</code> out of our <code>zoltar</code> function and <code>map</code> it at the time of calling, but it&apos;s helpful to see how the <code>Right</code> branch differs. We use <code>_</code> in the right branch&apos;s type signature to indicate it&apos;s a value that should be ignored (In some browsers you have to use <code>console.log.bind(console)</code> to use it first class).</p>
<p>I&apos;d like to take this opportunity to point out something you may have missed: <code>fortune</code>, despite its use with <code>Either</code> in this example, is completely ignorant of any functors milling about. This was also the case with <code>finishTransaction</code> in the previous example. At the time of calling, a function can be surrounded by <code>map</code>, which transforms it from a non-functory function to a functory one, in informal terms. We call this process <em>lifting</em>. Functions tend to be better off working with normal data types rather than container types, then <em>lifted</em> into the right container as deemed necessary. This leads to simpler, more reusable functions that can be altered to work with any functor on demand.</p>
<p><code>Either</code> is great for casual errors like validation as well as more serious, stop the show errors like missing files or broken sockets. Try replacing some of the <code>Maybe</code> examples with <code>Either</code> to give better feedback.</p>
<p>Now, I can&apos;t help but feel I&apos;ve done <code>Either</code> a disservice by introducing it as merely a container for error messages. It captures logical disjunction (a.k.a <code>||</code>) in a type. It also encodes the idea of a <em>Coproduct</em> from category theory, which won&apos;t be touched on in this book, but is well worth reading up on as there&apos;s properties to be exploited. It is the canonical sum type (or disjoint union of sets) because its amount of possible inhabitants is the sum of the two contained types (I know that&apos;s a bit hand wavy so here&apos;s a <a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types" target="_blank">great article</a>). There are many things <code>Either</code> can be, but as a functor, it is used for its error handling.</p>
<p>Just like with <code>Maybe</code>, we have little <code>either</code>, which behaves similarly, but takes two functions instead of one and a static value. Each function should return the same type:</p>
<pre><code class="lang-js"><span class="hljs-comment">// either :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c</span>
<span class="hljs-keyword">const</span> either = curry((f, g, e) =&gt; {
  <span class="hljs-keyword">let</span> result;

  <span class="hljs-keyword">switch</span> (e.constructor) {
    <span class="hljs-keyword">case</span> Left:
      result = f(e.$value);
      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> Right:
      result = g(e.$value);
      <span class="hljs-keyword">break</span>;

    <span class="hljs-comment">// No Default</span>
  }

  <span class="hljs-keyword">return</span> result;
});

<span class="hljs-comment">// zoltar :: User -&gt; _</span>
<span class="hljs-keyword">const</span> zoltar = compose(<span class="hljs-built_in">console</span>.log, either(id, fortune), getAge(moment()));

zoltar({ birthDate: <span class="hljs-string">&apos;2005-12-12&apos;</span> });
<span class="hljs-comment">// &apos;If you survive, you will be 10&apos;</span>
<span class="hljs-comment">// undefined</span>

zoltar({ birthDate: <span class="hljs-string">&apos;balloons!&apos;</span> });
<span class="hljs-comment">// &apos;Birth date could not be parsed&apos;</span>
<span class="hljs-comment">// undefined</span>
</code></pre>
<p>Finally, a use for that mysterious <code>id</code> function. It simply parrots back the value in the <code>Left</code> to pass the error message to <code>console.log</code>. We&apos;ve made our fortune-telling app more robust by enforcing error handling from within <code>getAge</code>. We either slap the user with a hard truth like a high five from a palm reader or we carry on with our process. And with that, we&apos;re ready to move on to an entirely different type of functor.</p>
<h2 id="old-mcdonald-had-effects">Old McDonald Had Effects...</h2>
<p><img src="images/dominoes.jpg" alt="dominoes.. need a reference"></p>
<p>In our chapter about purity we saw a peculiar example of a pure function. This function contained a side-effect, but we dubbed it pure by wrapping its action in another function. Here&apos;s another example of this:</p>
<pre><code class="lang-js"><span class="hljs-comment">// getFromStorage :: String -&gt; (_ -&gt; String)</span>
<span class="hljs-keyword">const</span> getFromStorage = key =&gt; () =&gt; localStorage[key];
</code></pre>
<p>Had we not surrounded its guts in another function, <code>getFromStorage</code> would vary its output depending on external circumstance. With the sturdy wrapper in place, we will always get the same output per input: a function that, when called, will retrieve a particular item from <code>localStorage</code>. And just like that (maybe throw in a few Hail Mary&apos;s) we&apos;ve cleared our conscience and all is forgiven.</p>
<p>Except, this isn&apos;t particularly useful now is it. Like a collectible action figure in its original packaging, we can&apos;t actually play with it. If only there were a way to reach inside of the container and get at its contents... Enter <code>IO</code>.</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IO</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(x) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IO(() =&gt; x);
  }

  <span class="hljs-keyword">constructor</span>(fn) {
    <span class="hljs-keyword">this</span>.$value = fn;
  }

  map(fn) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IO(compose(fn, <span class="hljs-keyword">this</span>.$value));
  }

  inspect() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`IO(<span class="hljs-subst">${inspect(this.$value)}</span>)`</span>;
  }
}
</code></pre>
<p><code>IO</code> differs from the previous functors in that the <code>$value</code> is always a function. We don&apos;t
think of its <code>$value</code> as a function, however - that is an implementation detail and we best
ignore it. What is happening is exactly what we saw with the <code>getFromStorage</code> example: <code>IO</code>
delays the impure action by capturing it in a function wrapper. As such, we think of <code>IO</code> as
containing the return value of the wrapped action and not the wrapper itself. This is apparent
in the <code>of</code> function: we have an <code>IO(x)</code>, the <code>IO(() =&gt; x)</code> is just necessary to
avoid evaluation. Note that, to simplify reading, we&apos;ll show the hypothetical value contained
in the <code>IO</code> as result; however in practice, you can&apos;t tell what this value is until you&apos;ve
actually unleashed the effects!</p>
<p>Let&apos;s see it in use:</p>
<pre><code class="lang-js"><span class="hljs-comment">// ioWindow :: IO Window</span>
<span class="hljs-keyword">const</span> ioWindow = <span class="hljs-keyword">new</span> IO(() =&gt; <span class="hljs-built_in">window</span>);

ioWindow.map(win =&gt; win.innerWidth);
<span class="hljs-comment">// IO(1430)</span>

ioWindow
  .map(prop(<span class="hljs-string">&apos;location&apos;</span>))
  .map(prop(<span class="hljs-string">&apos;href&apos;</span>))
  .map(split(<span class="hljs-string">&apos;/&apos;</span>));
<span class="hljs-comment">// IO([&apos;http:&apos;, &apos;&apos;, &apos;localhost:8000&apos;, &apos;blog&apos;, &apos;posts&apos;])</span>


<span class="hljs-comment">// $ :: String -&gt; IO [DOM]</span>
<span class="hljs-keyword">const</span> $ = selector =&gt; <span class="hljs-keyword">new</span> IO(() =&gt; <span class="hljs-built_in">document</span>.querySelectorAll(selector));

$(<span class="hljs-string">&apos;#myDiv&apos;</span>).map(head).map(div =&gt; div.innerHTML);
<span class="hljs-comment">// IO(&apos;I am some inner html&apos;)</span>
</code></pre>
<p>Here, <code>ioWindow</code> is an actual <code>IO</code> that we can <code>map</code> over straight away, whereas <code>$</code> is a function that returns an <code>IO</code> after it&apos;s called. I&apos;ve written out the <em>conceptual</em> return values to better express the <code>IO</code>, though, in reality, it will always be <code>{ $value: [Function] }</code>. When we <code>map</code> over our <code>IO</code>, we stick that function at the end of a composition which, in turn, becomes the new <code>$value</code> and so on. Our mapped functions do not run, they get tacked on the end of a computation we&apos;re building up, function by function, like carefully placing dominoes that we don&apos;t dare tip over. The result is reminiscent of Gang of Four&apos;s command pattern or a queue.</p>
<p>Take a moment to channel your functor intuition. If we see past the implementation details, we should feel right at home mapping over any container no matter its quirks or idiosyncrasies. We have the functor laws, which we will explore toward the end of the chapter, to thank for this pseudo-psychic power. At any rate, we can finally play with impure values without sacrificing our precious purity.</p>
<p>Now, we&apos;ve caged the beast, but we&apos;ll still have to set it free at some point. Mapping over our <code>IO</code> has built up a mighty impure computation and running it is surely going to disturb the peace. So where and when can we pull the trigger? Is it even possible to run our <code>IO</code> and still wear white at our wedding? The answer is yes, if we put the onus on the calling code. Our pure code, despite the nefarious plotting and scheming, maintains its innocence and it&apos;s the caller who gets burdened with the responsibility of actually running the effects. Let&apos;s see an example to make this concrete.</p>
<pre><code class="lang-js"><span class="hljs-comment">// url :: IO String</span>
<span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> IO(() =&gt; <span class="hljs-built_in">window</span>.location.href);

<span class="hljs-comment">// toPairs :: String -&gt; [[String]]</span>
<span class="hljs-keyword">const</span> toPairs = compose(map(split(<span class="hljs-string">&apos;=&apos;</span>)), split(<span class="hljs-string">&apos;&amp;&apos;</span>));

<span class="hljs-comment">// params :: String -&gt; [[String]]</span>
<span class="hljs-keyword">const</span> params = compose(toPairs, last, split(<span class="hljs-string">&apos;?&apos;</span>));

<span class="hljs-comment">// findParam :: String -&gt; IO Maybe [String]</span>
<span class="hljs-keyword">const</span> findParam = key =&gt; map(compose(Maybe.of, find(compose(eq(key), head)), params), url);

<span class="hljs-comment">// -- Impure calling code ----------------------------------------------</span>

<span class="hljs-comment">// run it by calling $value()!</span>
findParam(<span class="hljs-string">&apos;searchTerm&apos;</span>).$value();
<span class="hljs-comment">// Just([&apos;searchTerm&apos;, &apos;wafflehouse&apos;])</span>
</code></pre>
<p>Our library keeps its hands clean by wrapping <code>url</code> in an <code>IO</code> and passing the buck to the caller. You might have also noticed that we have stacked our containers; it&apos;s perfectly reasonable to have a <code>IO(Maybe([x]))</code>, which is three functors deep (<code>Array</code> is most definitely a mappable container type) and exceptionally expressive.</p>
<p>There&apos;s something that&apos;s been bothering me and we should rectify it immediately: <code>IO</code>&apos;s <code>$value</code> isn&apos;t really its contained value, nor is it a private property. It is the pin in the grenade and it is meant to be pulled by a caller in the most public of ways. Let&apos;s rename this property to <code>unsafePerformIO</code> to remind our users of its volatility.</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IO</span> </span>{
  <span class="hljs-keyword">constructor</span>(io) {
    <span class="hljs-keyword">this</span>.unsafePerformIO = io;
  }

  map(fn) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IO(compose(fn, <span class="hljs-keyword">this</span>.unsafePerformIO));
  }
}
</code></pre>
<p>There, much better. Now our calling code becomes <code>findParam(&apos;searchTerm&apos;).unsafePerformIO()</code>, which is clear as day to users (and readers) of the application.</p>
<p><code>IO</code> will be a loyal companion, helping us tame those feral impure actions. Next, we&apos;ll see a type similar in spirit, but having a drastically different use case.</p>
<h2 id="asynchronous-tasks">Asynchronous Tasks</h2>
<p>Callbacks are the narrowing spiral staircase to hell. They are control flow as designed by M.C. Escher. With each nested callback squeezed in between the jungle gym of curly braces and parenthesis, they feel like limbo in an oubliette (how low can we go?!). I&apos;m getting claustrophobic chills just thinking about them. Not to worry, we have a much better way of dealing with asynchronous code and it starts with an &quot;F&quot;.</p>
<p>The internals are a bit too complicated to spill out all over the page here so we will use <code>Data.Task</code> (previously <code>Data.Future</code>) from Quildreen Motta&apos;s fantastic <a href="https://folktale.origamitower.com/" target="_blank">Folktale</a>. Behold some example usage:</p>
<pre><code class="lang-js"><span class="hljs-comment">// -- Node readFile example ------------------------------------------</span>

<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;fs&apos;</span>);

<span class="hljs-comment">// readFile :: String -&gt; Task Error String</span>
<span class="hljs-keyword">const</span> readFile = filename =&gt; <span class="hljs-keyword">new</span> Task((reject, result) =&gt; {
  fs.readFile(filename, (err, data) =&gt; (err ? reject(err) : result(data)));
});

readFile(<span class="hljs-string">&apos;metamorphosis&apos;</span>).map(split(<span class="hljs-string">&apos;\n&apos;</span>)).map(head);
<span class="hljs-comment">// Task(&apos;One morning, as Gregor Samsa was waking up from anxious dreams, he discovered that</span>
<span class="hljs-comment">// in bed he had been changed into a monstrous verminous bug.&apos;)</span>


<span class="hljs-comment">// -- jQuery getJSON example -----------------------------------------</span>

<span class="hljs-comment">// getJSON :: String -&gt; {} -&gt; Task Error JSON</span>
<span class="hljs-keyword">const</span> getJSON = curry((url, params) =&gt; <span class="hljs-keyword">new</span> Task((reject, result) =&gt; {
  $.getJSON(url, params, result).fail(reject);
}));

getJSON(<span class="hljs-string">&apos;/video&apos;</span>, { id: <span class="hljs-number">10</span> }).map(prop(<span class="hljs-string">&apos;title&apos;</span>));
<span class="hljs-comment">// Task(&apos;Family Matters ep 15&apos;)</span>


<span class="hljs-comment">// -- Default Minimal Context ----------------------------------------</span>

<span class="hljs-comment">// We can put normal, non futuristic values inside as well</span>
Task.of(<span class="hljs-number">3</span>).map(three =&gt; three + <span class="hljs-number">1</span>);
<span class="hljs-comment">// Task(4)</span>
</code></pre>
<p>The functions I&apos;m calling <code>reject</code> and <code>result</code> are our error and success callbacks, respectively. As you can see, we simply <code>map</code> over the <code>Task</code> to work on the future value as if it was right there in our grasp. By now <code>map</code> should be old hat.</p>
<p>If you&apos;re familiar with promises, you might recognize the function <code>map</code> as <code>then</code> with <code>Task</code> playing the role of our promise. Don&apos;t fret if you aren&apos;t familiar with promises, we won&apos;t be using them anyhow because they are not pure, but the analogy holds nonetheless.</p>
<p>Like <code>IO</code>, <code>Task</code> will patiently wait for us to give it the green light before running. In fact, because it waits for our command, <code>IO</code> is effectively subsumed by <code>Task</code> for all things asynchronous; <code>readFile</code> and <code>getJSON</code> don&apos;t require an extra <code>IO</code> container to be pure. What&apos;s more, <code>Task</code> works in a similar fashion when we <code>map</code> over it: we&apos;re placing instructions for the future like a chore chart in a time capsule - an act of sophisticated technological procrastination.</p>
<p>To run our <code>Task</code>, we must call the method <code>fork</code>. This works like <code>unsafePerformIO</code>, but as the name suggests, it will fork our process and evaluation continues on without blocking our thread. This can be implemented in numerous ways with threads and such, but here it acts as a normal async call would and the big wheel of the event loop keeps on turning. Let&apos;s look at <code>fork</code>:</p>
<pre><code class="lang-js"><span class="hljs-comment">// -- Pure application -------------------------------------------------</span>
<span class="hljs-comment">// blogPage :: Posts -&gt; HTML</span>
<span class="hljs-keyword">const</span> blogPage = Handlebars.compile(blogTemplate);

<span class="hljs-comment">// renderPage :: Posts -&gt; HTML</span>
<span class="hljs-keyword">const</span> renderPage = compose(blogPage, sortBy(prop(<span class="hljs-string">&apos;date&apos;</span>)));

<span class="hljs-comment">// blog :: Params -&gt; Task Error HTML</span>
<span class="hljs-keyword">const</span> blog = compose(map(renderPage), getJSON(<span class="hljs-string">&apos;/posts&apos;</span>));


<span class="hljs-comment">// -- Impure calling code ----------------------------------------------</span>
blog({}).fork(
  error =&gt; $(<span class="hljs-string">&apos;#error&apos;</span>).html(error.message),
  page =&gt; $(<span class="hljs-string">&apos;#main&apos;</span>).html(page),
);

$(<span class="hljs-string">&apos;#spinner&apos;</span>).show();
</code></pre>
<p>Upon calling <code>fork</code>, the <code>Task</code> hurries off to find some posts and render the page. Meanwhile, we show a spinner since <code>fork</code> does not wait for a response. Finally, we will either display an error or render the page onto the screen depending if the <code>getJSON</code> call succeeded or not.</p>
<p>Take a moment to consider how linear the control flow is here. We just read bottom to top, right to left even though the program will actually jump around a bit during execution. This makes reading and reasoning about our application simpler than having to bounce between callbacks and error handling blocks.</p>
<p>Goodness, would you look at that, <code>Task</code> has also swallowed up <code>Either</code>! It must do so in order to handle futuristic failures since our normal control flow does not apply in the async world. This is all well and good as it provides sufficient and pure error handling out of the box.</p>
<p>Even with <code>Task</code>, our <code>IO</code> and <code>Either</code> functors are not out of a job. Bear with me on a quick example that leans toward the more complex and hypothetical side, but is useful for illustrative purposes.</p>
<pre><code class="lang-js"><span class="hljs-comment">// Postgres.connect :: Url -&gt; IO DbConnection</span>
<span class="hljs-comment">// runQuery :: DbConnection -&gt; ResultSet</span>
<span class="hljs-comment">// readFile :: String -&gt; Task Error String</span>

<span class="hljs-comment">// -- Pure application -------------------------------------------------</span>

<span class="hljs-comment">// dbUrl :: Config -&gt; Either Error Url</span>
<span class="hljs-keyword">const</span> dbUrl = ({ uname, pass, host, db }) =&gt; {
  <span class="hljs-keyword">if</span> (uname &amp;&amp; pass &amp;&amp; host &amp;&amp; db) {
    <span class="hljs-keyword">return</span> Either.of(<span class="hljs-string">`db:pg://<span class="hljs-subst">${uname}</span>:<span class="hljs-subst">${pass}</span>@<span class="hljs-subst">${host}</span>5432/<span class="hljs-subst">${db}</span>`</span>);
  }

  <span class="hljs-keyword">return</span> left(<span class="hljs-built_in">Error</span>(<span class="hljs-string">&apos;Invalid config!&apos;</span>));
};

<span class="hljs-comment">// connectDb :: Config -&gt; Either Error (IO DbConnection)</span>
<span class="hljs-keyword">const</span> connectDb = compose(map(Postgres.connect), dbUrl);

<span class="hljs-comment">// getConfig :: Filename -&gt; Task Error (Either Error (IO DbConnection))</span>
<span class="hljs-keyword">const</span> getConfig = compose(map(compose(connectDb, <span class="hljs-built_in">JSON</span>.parse)), readFile);


<span class="hljs-comment">// -- Impure calling code ----------------------------------------------</span>

getConfig(<span class="hljs-string">&apos;db.json&apos;</span>).fork(
  logErr(<span class="hljs-string">&apos;couldn\&apos;t read file&apos;</span>),
  either(<span class="hljs-built_in">console</span>.log, map(runQuery)),
);
</code></pre>
<p>In this example, we still make use of <code>Either</code> and <code>IO</code> from within the success branch of <code>readFile</code>. <code>Task</code> takes care of the impurities of reading a file asynchronously, but we still deal with validating the config with <code>Either</code> and wrangling the db connection with <code>IO</code>. So you see, we&apos;re still in business for all things synchronous.</p>
<p>I could go on, but that&apos;s all there is to it. Simple as <code>map</code>.</p>
<p>In practice, you&apos;ll likely have multiple asynchronous tasks in one workflow and we haven&apos;t yet acquired the full container apis to tackle this scenario. Not to worry, we&apos;ll look at monads and such soon, but first, we must examine the maths that make this all possible.</p>
<h2 id="a-spot-of-theory">A Spot of Theory</h2>
<p>As mentioned before, functors come from category theory and satisfy a few laws. Let&apos;s first explore these useful properties.</p>
<pre><code class="lang-js"><span class="hljs-comment">// identity</span>
map(id) === id;

<span class="hljs-comment">// composition</span>
compose(map(f), map(g)) === map(compose(f, g));
</code></pre>
<p>The <em>identity</em> law is simple, but important. These laws are runnable bits of code so we can try them on our own functors to validate their legitimacy.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> idLaw1 = map(id);
<span class="hljs-keyword">const</span> idLaw2 = id;

idLaw1(Container.of(<span class="hljs-number">2</span>)); <span class="hljs-comment">// Container(2)</span>
idLaw2(Container.of(<span class="hljs-number">2</span>)); <span class="hljs-comment">// Container(2)</span>
</code></pre>
<p>You see, they are equal. Next let&apos;s look at composition.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> compLaw1 = compose(map(append(<span class="hljs-string">&apos; world&apos;</span>)), map(append(<span class="hljs-string">&apos; cruel&apos;</span>)));
<span class="hljs-keyword">const</span> compLaw2 = map(compose(append(<span class="hljs-string">&apos; world&apos;</span>), append(<span class="hljs-string">&apos; cruel&apos;</span>)));

compLaw1(Container.of(<span class="hljs-string">&apos;Goodbye&apos;</span>)); <span class="hljs-comment">// Container(&apos;Goodbye cruel world&apos;)</span>
compLaw2(Container.of(<span class="hljs-string">&apos;Goodbye&apos;</span>)); <span class="hljs-comment">// Container(&apos;Goodbye cruel world&apos;)</span>
</code></pre>
<p>In category theory, functors take the objects and morphisms of a category and map them to a different category. By definition, this new category must have an identity and the ability to compose morphisms, but we needn&apos;t check because the aforementioned laws ensure these are preserved.</p>
<p>Perhaps our definition of a category is still a bit fuzzy. You can think of a category as a network of objects with morphisms that connect them. So a functor would map the one category to the other without breaking the network. If an object <code>a</code> is in our source category <code>C</code>, when we map it to category <code>D</code> with functor <code>F</code>, we refer to that object as <code>F a</code> (If you put it together what does that spell?!). Perhaps, it&apos;s better to look at a diagram:</p>
<p><img src="images/catmap.png" alt="Categories mapped"></p>
<p>For instance, <code>Maybe</code> maps our category of types and functions to a category where each object may not exist and each morphism has a <code>null</code> check. We accomplish this in code by surrounding each function with <code>map</code> and each type with our functor. We know that each of our normal types and functions will continue to compose in this new world. Technically, each functor in our code maps to a sub category of types and functions which makes all functors a particular brand called endofunctors, but for our purposes, we&apos;ll think of it as a different category.</p>
<p>We can also visualize the mapping of a morphism and its corresponding objects with this diagram:</p>
<p><img src="images/functormap.png" alt="functor diagram"></p>
<p>In addition to visualizing the mapped morphism from one category to another under the functor <code>F</code>, we see that the diagram commutes, which is to say, if you follow the arrows each route produces the same result. The different routes mean different behavior, but we always end at the same type. This formalism gives us principled ways to reason about our code - we can boldly apply formulas without having to parse and examine each individual scenario. Let&apos;s take a concrete example.</p>
<pre><code class="lang-js"><span class="hljs-comment">// topRoute :: String -&gt; Maybe String</span>
<span class="hljs-keyword">const</span> topRoute = compose(Maybe.of, reverse);

<span class="hljs-comment">// bottomRoute :: String -&gt; Maybe String</span>
<span class="hljs-keyword">const</span> bottomRoute = compose(map(reverse), Maybe.of);

topRoute(<span class="hljs-string">&apos;hi&apos;</span>); <span class="hljs-comment">// Just(&apos;ih&apos;)</span>
bottomRoute(<span class="hljs-string">&apos;hi&apos;</span>); <span class="hljs-comment">// Just(&apos;ih&apos;)</span>
</code></pre>
<p>Or visually:</p>
<p><img src="images/functormapmaybe.png" alt="functor diagram 2"></p>
<p>We can instantly see and refactor code based on properties held by all functors.</p>
<p>Functors can stack:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> nested = Task.of([Either.of(<span class="hljs-string">&apos;pillows&apos;</span>), left(<span class="hljs-string">&apos;no sleep for you&apos;</span>)]);

map(map(map(toUpperCase)), nested);
<span class="hljs-comment">// Task([Right(&apos;PILLOWS&apos;), Left(&apos;no sleep for you&apos;)])</span>
</code></pre>
<p>What we have here with <code>nested</code> is a future array of elements that might be errors. We <code>map</code> to peel back each layer and run our function on the elements. We see no callbacks, if/else&apos;s, or for loops; just an explicit context. We do, however, have to <code>map(map(map(f)))</code>. We can instead compose functors. You heard me correctly:</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compose</span> </span>{
  <span class="hljs-keyword">constructor</span>(fgx) {
    <span class="hljs-keyword">this</span>.getCompose = fgx;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(fgx) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Compose(fgx);
  }

  map(fn) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Compose(map(map(fn), <span class="hljs-keyword">this</span>.getCompose));
  }
}

<span class="hljs-keyword">const</span> tmd = Task.of(Maybe.of(<span class="hljs-string">&apos;Rock over London&apos;</span>));

<span class="hljs-keyword">const</span> ctmd = Compose.of(tmd);

<span class="hljs-keyword">const</span> ctmd2 = map(append(<span class="hljs-string">&apos;, rock on, Chicago&apos;</span>), ctmd);
<span class="hljs-comment">// Compose(Task(Just(&apos;Rock over London, rock on, Chicago&apos;)))</span>

ctmd2.getCompose;
<span class="hljs-comment">// Task(Just(&apos;Rock over London, rock on, Chicago&apos;))</span>
</code></pre>
<p>There, one <code>map</code>. Functor composition is associative and earlier, we defined <code>Container</code>, which is actually called the <code>Identity</code> functor. If we have identity and associative composition we have a category. This particular category has categories as objects and functors as morphisms, which is enough to make one&apos;s brain perspire. We won&apos;t delve too far into this, but it&apos;s nice to appreciate the architectural implications or even just the simple abstract beauty in the pattern.</p>
<h2 id="in-summary">In Summary</h2>
<p>We&apos;ve seen a few different functors, but there are infinitely many. Some notable omissions are iterable data structures like trees, lists, maps, pairs, you name it. Event streams and observables are both functors. Others can be for encapsulation or even just type modelling. Functors are all around us and we&apos;ll use them extensively throughout the book.</p>
<p>What about calling a function with multiple functor arguments? How about working with an order sequence of impure or async actions? We haven&apos;t yet acquired the full tool set for working in this boxed up world. Next, we&apos;ll cut right to the chase and look at monads.</p>
<p><a href="ch09.html">Chapter 09: Monadic Onions</a></p>
<h2 id="exercises">Exercises</h2>
<p><div class="exercise">
	<div class="header">Exercise</div>
	<div class="alert alert-success">
	    <b>Correct!</b>
	</div>

	<div class="alert alert-danger error-message">
	    <b>False!</b>
	</div>

	<div class="message">
	  
Use `add` and `map` to make a function that increments a value inside a functor.  
  

	</div>
	<div class="editor" style="height: 20px">// incrF :: Functor f =&gt; f Int -&gt; f Int
const incrF = undefined;</div>

	<pre class="hidden code-solution">const incrF = map(add(1));</pre>
	<pre class="hidden code-validation">/* globals incrF */

assert(
  incrF(Identity.of(2)).$value === 3,
  &apos;The function gives incorrect results.&apos;,
);

assert(
  add.partially,
  &apos;The answer is incorrect; hint: add is currified!&apos;,
);

assert(
  map.partially,
  &apos;The answer is incorrect; hint: map is currified!&apos;,
);</pre>
	
	<pre class="hidden code-context">// NOTE We keep named function here to leverage this in the `compose` function,
// and later on in the validations scripts.

/* eslint-disable prefer-arrow-callback */


/* ---------- Internals ---------- */

function namedAs(value, fn) {
  Object.defineProperty(fn, &apos;name&apos;, { value });
  return fn;
}


// NOTE This file is loaded by gitbook&apos;s exercises plugin. When it does, there&apos;s an
// `assert` function available in the global scope.

/* eslint-disable no-undef, global-require */
if (typeof assert !== &apos;function&apos; &amp;&amp; typeof require === &apos;function&apos;) {
  global.assert = require(&apos;assert&apos;);
}

assert.arrayEqual = function assertArrayEqual(actual, expected, message = &apos;arrayEqual&apos;) {
  if (actual.length !== expected.length) {
    throw new Error(message);
  }

  for (let i = 0; i &lt; expected.length; i += 1) {
    if (expected[i] !== actual[i]) {
      throw new Error(message);
    }
  }
};
/* eslint-enable no-undef, global-require */


function inspect(x) {
  if (x &amp;&amp; typeof x.inspect === &apos;function&apos;) {
    return x.inspect();
  }

  function inspectFn(f) {
    return f.name ? f.name : f.toString();
  }

  function inspectTerm(t) {
    switch (typeof t) {
      case &apos;string&apos;:
        return `&apos;${t}&apos;`;
      case &apos;object&apos;: {
        const ts = Object.keys(t).map(k =&gt; [k, inspect(t[k])]);
        return `{${ts.map(kv =&gt; kv.join(&apos;: &apos;)).join(&apos;, &apos;)}}`;
      }
      default:
        return String(t);
    }
  }

  function inspectArgs(args) {
    return Array.isArray(args) ? `[${args.map(inspect).join(&apos;, &apos;)}]` : inspectTerm(args);
  }

  return (typeof x === &apos;function&apos;) ? inspectFn(x) : inspectArgs(x);
}


/* eslint-disable no-param-reassign */
function withSpyOn(prop, obj, fn) {
  const orig = obj[prop];
  let called = false;
  obj[prop] = function spy(...args) {
    called = true;
    return orig.call(this, ...args);
  };
  fn();
  obj[prop] = orig;
  return called;
}
/* eslint-enable no-param-reassign */


const typeMismatch = (src, got, fn) =&gt; `Type Mismatch in function &apos;${fn}&apos;

        ${fn} :: ${got}

      instead of

        ${fn} :: ${src}`;


const capitalize = s =&gt; `${s[0].toUpperCase()}${s.substring(1)}`;


const ordinal = (i) =&gt; {
  switch (i) {
    case 1:
      return &apos;1st&apos;;
    case 2:
      return &apos;2nd&apos;;
    case 3:
      return &apos;3rd&apos;;
    default:
      return `${i}th`; // NOTE won&apos;t get any much bigger ...
  }
};

const getType = (x) =&gt; {
  if (x === null) {
    return &apos;Null&apos;;
  }

  if (typeof x === &apos;undefined&apos;) {
    return &apos;()&apos;;
  }

  if (Array.isArray(x)) {
    return `[${x[0] ? getType(x[0]) : &apos;?&apos;}]`;
  }

  if (typeof x.getType === &apos;function&apos;) {
    return x.getType();
  }

  if (x.constructor &amp;&amp; x.constructor.name) {
    return x.constructor.name;
  }

  return capitalize(typeof x);
};


/* ---------- Essential FP Functions ---------- */

// NOTE A slightly pumped up version of `curry` which also keeps track of
// whether a function was called partially or with all its arguments at once.
// This is useful to provide insights during validation of exercises.
function curry(fn) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;function -&gt; ?&apos;, [getType(fn), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;curry&apos;),
  );

  const arity = fn.length;

  return namedAs(fn.name, function $curry(...args) {
    $curry.partially = this &amp;&amp; this.partially;

    if (args.length &lt; arity) {
      return namedAs(fn.name, $curry.bind({ partially: true }, ...args));
    }

    return fn.call(this || { partially: false }, ...args);
  });
}


// NOTE A slightly pumped up version of `compose` which also keeps track of the chain
// of callees. In the end, a function created with `compose` holds a `callees` variable
// with the list of all the callees&apos; names.
// This is useful to provide insights during validation of exercises
function compose(...fns) {
  const n = fns.length;

  return function $compose(...args) {
    $compose.callees = [];

    let $args = args;

    for (let i = n - 1; i &gt;= 0; i -= 1) {
      const fn = fns[i];

      assert(
        typeof fn === &apos;function&apos;,
        `Invalid Composition: ${ordinal(n - i)} element in a composition isn&apos;t a function`,
      );

      $compose.callees.push(fn.name);
      $args = [fn.call(null, ...$args)];
    }

    return $args[0];
  };
}


/* ---------- Algebraic Data Structures ---------- */

class Either {
  static of(x) {
    return new Right(x); // eslint-disable-line no-use-before-define
  }

  constructor(x) {
    this.$value = x;
  }
}


class Left extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return true;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return false;
  }

  ap() {
    return this;
  }

  chain() {
    return this;
  }

  inspect() {
    return `Left(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ${getType(this.$value)} ?)`;
  }

  join() {
    return this;
  }

  map() {
    return this;
  }

  sequence(of) {
    return of(this);
  }

  traverse(of, fn) {
    return of(this);
  }
}


class Right extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return false;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return true;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return fn(this.$value);
  }

  inspect() {
    return `Right(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ? ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Either.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    fn(this.$value).map(Either.of);
  }
}


class Identity {
  static of(x) {
    return new Identity(x);
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `Identity(${inspect(this.$value)})`;
  }

  getType() {
    return `(Identity ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Identity.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return fn(this.$value).map(Identity.of);
  }
}

class IO {
  static of(x) {
    return new IO(() =&gt; x);
  }

  constructor(io) {
    assert(
      typeof io === &apos;function&apos;,
      &apos;invalid `io` operation given to IO constructor. Use `IO.of` if you want to lift a value in a default minimal IO context.&apos;,
    );

    this.unsafePerformIO = io;
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `IO(${inspect(this.unsafePerformIO())})`;
  }

  getType() {
    return `(IO ${getType(this.unsafePerformIO())})`;
  }


  join() {
    return this.unsafePerformIO();
  }

  map(fn) {
    return new IO(compose(fn, this.unsafePerformIO));
  }
}


class Map {
  constructor(x) {
    assert(
      typeof x === &apos;object&apos; &amp;&amp; x !== null,
      &apos;tried to create `Map` with non object-like&apos;,
    );

    this.$value = x;
  }

  inspect() {
    return `Map(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[Object.keys(this.$value)[0]];

    return `(Map String ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  insert(k, v) {
    const singleton = {};
    singleton[k] = v;
    return new Map(Object.assign({}, this.$value, singleton));
  }

  reduce(fn, zero) {
    return this.reduceWithKeys((acc, _, k) =&gt; fn(acc, k), zero);
  }

  reduceWithKeys(fn, zero) {
    return Object.keys(this.$value)
      .reduce((acc, k) =&gt; fn(acc, this.$value[k], k), zero);
  }

  map(fn) {
    return new Map(this.reduceWithKeys((obj, v, k) =&gt; {
      obj[k] = fn(v); // eslint-disable-line no-param-reassign
      return obj;
    }, {}));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.reduceWithKeys(
      (f, a, k) =&gt; fn(a).map(b =&gt; m =&gt; m.insert(k, b)).ap(f),
      of(new Map({})),
    );
  }
}


class List {
  static of(x) {
    return new List([x]);
  }

  constructor(xs) {
    assert(
      Array.isArray(xs),
      &apos;tried to create `List` from non-array&apos;,
    );

    this.$value = xs;
  }

  concat(x) {
    return new List(this.$value.concat(x));
  }

  inspect() {
    return `List(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[0];

    return `(List ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  map(fn) {
    return new List(this.$value.map(fn));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.$value.reduce(
      (f, a) =&gt; fn(a).map(b =&gt; bs =&gt; bs.concat(b)).ap(f),
      of(new List([])),
    );
  }
}


class Maybe {
  static of(x) {
    return new Maybe(x);
  }

  get isNothing() {
    return this.$value === null || this.$value === undefined;
  }

  get isJust() {
    return !this.isNothing;
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return this.isNothing ? this : f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return this.isNothing ? &apos;Nothing&apos; : `Just(${inspect(this.$value)})`;
  }

  getType() {
    return `(Maybe ${this.isJust ? getType(this.$value) : &apos;?&apos;})`;
  }

  join() {
    return this.isNothing ? this : this.$value;
  }

  map(fn) {
    return this.isNothing ? this : Maybe.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.isNothing ? of(this) : fn(this.$value).map(Maybe.of);
  }
}


class Task {
  constructor(fork) {
    assert(
      typeof fork === &apos;function&apos;,
      &apos;invalid `fork` operation given to Task constructor. Use `Task.of` if you want to lift a value in a default minimal Task context.&apos;,
    );

    this.fork = fork;
  }

  static of(x) {
    return new Task((_, resolve) =&gt; resolve(x));
  }

  static rejected(x) {
    return new Task((reject, _) =&gt; reject(x));
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, x =&gt; fn(x).fork(reject, resolve)));
  }

  inspect() { // eslint-disable-line class-methods-use-this
    return &apos;Task(?)&apos;;
  }

  getType() { // eslint-disable-line class-methods-use-this
    return &apos;(Task ? ?)&apos;;
  }

  join() {
    return this.chain(x =&gt; x);
  }

  map(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, compose(resolve, fn)));
  }
}

// In nodejs the existance of a class method named `inspect` will trigger a deprecation warning
// when passing an instance to `console.log`:
// `(node:3845) [DEP0079] DeprecationWarning: Custom inspection function on Objects via .inspect() is deprecated`
// The solution is to alias the existing inspect method with the special inspect symbol exported by node
if (typeof module !== &apos;undefined&apos; &amp;&amp; typeof this !== &apos;undefined&apos; &amp;&amp; this.module !== module) {
  const customInspect = require(&apos;util&apos;).inspect.custom;
  const assignCustomInspect = it =&gt; it.prototype[customInspect] = it.prototype.inspect;
  [Left, Right, Identity, IO, Map, List, Maybe, Task].forEach(assignCustomInspect);
}

const identity = function identity(x) { return x; };

const either = curry(function either(f, g, e) {
  if (e.isLeft) {
    return f(e.$value);
  }

  return g(e.$value);
});

const left = function left(x) { return new Left(x); };

const maybe = curry(function maybe(v, f, m) {
  if (m.isNothing) {
    return v;
  }

  return f(m.$value);
});

const nothing = Maybe.of(null);

const reject = function reject(x) { return Task.rejected(x); };

const chain = curry(function chain(fn, m) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m a&apos;, [getType(fn), getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;chain&apos;),
  );

  return m.chain(fn);
});

const join = function join(m) {
  assert(
    typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; m (m a) -&gt; m a&apos;, [getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;join&apos;),
  );

  return m.join();
};

const map = curry(function map(fn, f) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof f.map === &apos;function&apos;,
    typeMismatch(&apos;Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b&apos;, [getType(fn), getType(f), &apos;f b&apos;].join(&apos; -&gt; &apos;), &apos;map&apos;),
  );

  return f.map(fn);
});

const sequence = curry(function sequence(of, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof x.sequence === &apos;function&apos;,
    typeMismatch(&apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; t (f a) -&gt; f (t a)&apos;, [getType(of), getType(x), &apos;f (t a)&apos;].join(&apos; -&gt; &apos;), &apos;sequence&apos;),
  );

  return x.sequence(of);
});

const traverse = curry(function traverse(of, fn, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof fn === &apos;function&apos; &amp;&amp; typeof x.traverse === &apos;function&apos;,
    typeMismatch(
      &apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)&apos;,
      [getType(of), getType(fn), getType(x), &apos;f (t b)&apos;].join(&apos; -&gt; &apos;),
      &apos;traverse&apos;,
    ),
  );

  return x.traverse(of, fn);
});

const unsafePerformIO = function unsafePerformIO(io) {
  assert(
    io instanceof IO,
    typeMismatch(&apos;IO a&apos;, getType(io), &apos;unsafePerformIO&apos;),
  );

  return io.unsafePerformIO();
};

const liftA2 = curry(function liftA2(fn, a1, a2) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2);
});

const liftA3 = curry(function liftA3(fn, a1, a2, a3) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;
      &amp;&amp; typeof a3.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2).ap(a3);
});

const always = curry(function always(a, b) { return a; });


/* ---------- Pointfree Classic Utilities ---------- */

const append = curry(function append(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return b.concat(a);
});

const add = curry(function add(a, b) {
  assert(
    typeof a === &apos;number&apos; &amp;&amp; typeof b === &apos;number&apos;,
    typeMismatch(&apos;Number -&gt; Number -&gt; Number&apos;, [getType(a), getType(b), &apos;Number&apos;].join(&apos; -&gt; &apos;), &apos;add&apos;),
  );

  return a + b;
});

const concat = curry(function concat(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return a.concat(b);
});

const eq = curry(function eq(a, b) {
  assert(
    getType(a) === getType(b),
    typeMismatch(&apos;a -&gt; a -&gt; Boolean&apos;, [getType(a), getType(b), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), eq),
  );

  return a === b;
});

const filter = curry(function filter(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; Boolean) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;filter&apos;),
  );

  return xs.filter(fn);
});

const flip = curry(function flip(fn, a, b) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;(a -&gt; b) -&gt; (b -&gt; a)&apos;, [getType(fn), &apos;(b -&gt; a)&apos;].join(&apos; -&gt; &apos;), &apos;flip&apos;),
  );

  return fn(b, a);
});

const forEach = curry(function forEach(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; ()) -&gt; [a] -&gt; ()&apos;, [getType(fn), getType(xs), &apos;()&apos;].join(&apos; -&gt; &apos;), &apos;forEach&apos;),
  );

  xs.forEach(fn);
});

const intercalate = curry(function intercalate(str, xs) {
  assert(
    typeof str === &apos;string&apos; &amp;&amp; Array.isArray(xs) &amp;&amp; (xs.length === 0 || typeof xs[0] === &apos;string&apos;),
    typeMismatch(&apos;String -&gt; [String] -&gt; String&apos;, [getType(str), getType(xs), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;intercalate&apos;),
  );

  return xs.join(str);
});

const head = function head(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;head&apos;),
  );

  return xs[0];
};

const last = function last(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;last&apos;),
  );

  return xs[xs.length - 1];
};

const match = curry(function match(re, str) {
  assert(
    re instanceof RegExp &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;RegExp -&gt; String -&gt; Boolean&apos;, [getType(re), getType(str), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), &apos;match&apos;),
  );

  return re.test(str);
});

const prop = curry(function prop(p, obj) {
  assert(
    typeof p === &apos;string&apos; &amp;&amp; typeof obj === &apos;object&apos; &amp;&amp; obj !== null,
    typeMismatch(&apos;String -&gt; Object -&gt; a&apos;, [getType(p), getType(obj), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;prop&apos;),
  );

  return obj[p];
});

const reduce = curry(function reduce(fn, zero, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b&apos;, [getType(fn), getType(zero), getType(xs), &apos;b&apos;].join(&apos; -&gt; &apos;), &apos;reduce&apos;),
  );

  return xs.reduce(
    function $reduceIterator($acc, $x) { return fn($acc, $x); },
    zero,
  );
});

const safeHead = namedAs(&apos;safeHead&apos;, compose(Maybe.of, head));

const safeProp = curry(function safeProp(p, obj) { return Maybe.of(prop(p, obj)); });

const sortBy = curry(function sortBy(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), &apos;[a]&apos;].join(&apos; -&gt; &apos;), &apos;sortBy&apos;),
  );

  return xs.sort((a, b) =&gt; {
    if (fn(a) === fn(b)) {
      return 0;
    }

    return fn(a) &gt; fn(b) ? 1 : -1;
  });
});

const split = curry(function split(s, str) {
  assert(
    typeof s === &apos;string&apos; &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; [String]&apos;, [getType(s), getType(str), &apos;[String]&apos;].join(&apos; -&gt; &apos;), &apos;split&apos;),
  );

  return str.split(s);
});

const take = curry(function take(n, xs) {
  assert(
    typeof n === &apos;number&apos; &amp;&amp; (Array.isArray(xs) || typeof xs === &apos;string&apos;),
    typeMismatch(&apos;Number -&gt; [a] -&gt; [a]&apos;, [getType(n), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;take&apos;),
  );

  return xs.slice(0, n);
});

const toLowerCase = function toLowerCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toLowerCase();
};

const toUpperCase = function toUpperCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toUpperCase();
};


/* ---------- Chapter 4 ---------- */

const keepHighest = function keepHighest(x, y) {
  try {
    keepHighest.calledBy = keepHighest.caller;
  } catch (err) {
    // NOTE node.js runs in strict mode and prohibit the usage of &apos;.caller&apos;
    // There&apos;s a ugly hack to retrieve the caller from stack trace.
    const [, caller] = /at (\S+)/.exec(err.stack.split(&apos;\n&apos;)[2]);

    keepHighest.calledBy = namedAs(caller, () =&gt; {});
  }

  return x &gt;= y ? x : y;
};


/* ---------- Chapter 5 ---------- */

const cars = [{
  name: &apos;Ferrari FF&apos;,
  horsepower: 660,
  dollar_value: 700000,
  in_stock: true,
}, {
  name: &apos;Spyker C12 Zagato&apos;,
  horsepower: 650,
  dollar_value: 648000,
  in_stock: false,
}, {
  name: &apos;Jaguar XKR-S&apos;,
  horsepower: 550,
  dollar_value: 132000,
  in_stock: true,
}, {
  name: &apos;Audi R8&apos;,
  horsepower: 525,
  dollar_value: 114200,
  in_stock: false,
}, {
  name: &apos;Aston Martin One-77&apos;,
  horsepower: 750,
  dollar_value: 1850000,
  in_stock: true,
}, {
  name: &apos;Pagani Huayra&apos;,
  horsepower: 700,
  dollar_value: 1300000,
  in_stock: false,
}];

const average = function average(xs) {
  return xs.reduce(add, 0) / xs.length;
};


/* ---------- Chapter 8 ---------- */

const albert = {
  id: 1,
  active: true,
  name: &apos;Albert&apos;,
  address: {
    street: {
      number: 22,
      name: &apos;Walnut St&apos;,
    },
  },
};

const gary = {
  id: 2,
  active: false,
  name: &apos;Gary&apos;,
  address: {
    street: {
      number: 14,
    },
  },
};

const theresa = {
  id: 3,
  active: true,
  name: &apos;Theresa&apos;,
};

const yi = { id: 4, name: &apos;Yi&apos;, active: true };

const showWelcome = namedAs(&apos;showWelcome&apos;, compose(concat(&apos;Welcome &apos;), prop(&apos;name&apos;)));

const checkActive = function checkActive(user) {
  return user.active
    ? Either.of(user)
    : left(&apos;Your account is not active&apos;);
};

const save = function save(user) {
  return new IO(() =&gt; Object.assign({}, user, { saved: true }));
};

const validateUser = curry(function validateUser(validate, user) {
  return validate(user).map(_ =&gt; user); // eslint-disable-line no-unused-vars
});


/* ---------- Chapter 9 ---------- */

const getFile = IO.of(&apos;/home/mostly-adequate/ch09.md&apos;);

const pureLog = function pureLog(str) { return new IO(() =&gt; { console.log(str); return str; }); };

const addToMailingList = function addToMailingList(email) { return IO.of([email]); };

const emailBlast = function emailBlast(list) { return IO.of(list.join(&apos;,&apos;)); };

const validateEmail = function validateEmail(x) {
  return /\S+@\S+\.\S+/.test(x)
    ? Either.of(x)
    : left(&apos;invalid email&apos;);
};


/* ---------- Chapter 10 ---------- */

const localStorage = { player1: albert, player2: theresa };

const game = curry(function game(p1, p2) { return `${p1.name} vs ${p2.name}`; });

const getFromCache = function getFromCache(x) { return new IO(() =&gt; localStorage[x]); };


/* ---------- Chapter 11 ---------- */

const findUserById = function findUserById(id) {
  switch (id) {
    case 1:
      return Task.of(Either.of(albert));

    case 2:
      return Task.of(Either.of(gary));

    case 3:
      return Task.of(Either.of(theresa));

    default:
      return Task.of(left(&apos;not found&apos;));
  }
};

const eitherToTask = namedAs(&apos;eitherToTask&apos;, either(Task.rejected, Task.of));


/* ---------- Chapter 12 ---------- */

const httpGet = function httpGet(route) { return Task.of(`json for ${route}`); };

const routes = new Map({
  &apos;/&apos;: &apos;/&apos;,
  &apos;/about&apos;: &apos;/about&apos;,
});

const validate = function validate(player) {
  return player.name
    ? Either.of(player)
    : left(&apos;must have name&apos;);
};

const readdir = function readdir(dir) {
  return Task.of([&apos;file1&apos;, &apos;file2&apos;, &apos;file3&apos;]);
};

const readfile = curry(function readfile(encoding, file) {
  return Task.of(`content of ${file} (${encoding})`);
});


/* ---------- Exports ---------- */

if (typeof module === &apos;object&apos;) {
  module.exports = {
    // Utils
    withSpyOn,

    // Essential FP helpers
    always,
    compose,
    curry,
    either,
    identity,
    inspect,
    left,
    liftA2,
    liftA3,
    maybe,
    nothing,
    reject,

    // Algebraic Data Structures
    Either,
    IO,
    Identity,
    Left,
    List,
    Map,
    Maybe,
    Right,
    Task,

    // Currified version of &apos;standard&apos; functions
    append,
    add,
    chain,
    concat,
    eq,
    filter,
    flip,
    forEach,
    head,
    intercalate,
    join,
    last,
    map,
    match,
    prop,
    reduce,
    safeHead,
    safeProp,
    sequence,
    sortBy,
    split,
    take,
    toLowerCase,
    toUpperCase,
    traverse,
    unsafePerformIO,

    // Chapter 04
    keepHighest,

    // Chapter 05
    cars,
    average,

    // Chapter 08
    albert,
    gary,
    theresa,
    yi,
    showWelcome,
    checkActive,
    save,
    validateUser,

    // Chapter 09
    getFile,
    pureLog,
    addToMailingList,
    emailBlast,
    validateEmail,

    // Chapter 10
    localStorage,
    getFromCache,
    game,

    // Chapter 11
    findUserById,
    eitherToTask,

    // Chapter 12
    httpGet,
    routes,
    validate,
    readdir,
    readfile,
  };
}</pre>
	

	<div class="buttons">
	    <a href="#" class="button size-2 action-submit">Submit</a>
	    <a href="#" class="button size-2 action-solution">Solution</a>
	</div>
</div>  </p>
<hr>
<p>Given the following User object:  </p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> user = { id: <span class="hljs-number">2</span>, name: <span class="hljs-string">&apos;Albert&apos;</span>, active: <span class="hljs-literal">true</span> };
</code></pre>
<p><div class="exercise">
	<div class="header">Exercise</div>
	<div class="alert alert-success">
	    <b>Correct!</b>
	</div>

	<div class="alert alert-danger error-message">
	    <b>False!</b>
	</div>

	<div class="message">
	  
Use `safeProp` and `head` to find the first initial of the user.  
  

	</div>
	<div class="editor" style="height: 20px">// initial :: User -&gt; Maybe String
const initial = undefined;</div>

	<pre class="hidden code-solution">const initial = compose(map(head), safeProp(&apos;name&apos;));</pre>
	<pre class="hidden code-validation">/* globals initial */

if (!(initial(albert) instanceof Maybe) &amp;&amp; initial.callees &amp;&amp; initial.callees[0] === &apos;safeProp&apos; &amp;&amp; initial.callees[1] === &apos;head&apos;) {
  throw new Error(&apos;The function gives incorrect results; hint: look carefully at the signatures of `safeProp` and `head`!&apos;);
}

assert(
  initial(albert).$value === &apos;A&apos;,
  &apos;The function gives incorrect results.&apos;,
);

assert.arrayEqual(
  initial.callees || [],
  [&apos;safeProp&apos;, &apos;map&apos;],
  &apos;The answer is incorrect; hint: you can compose `safeProp` with `head` in a declarative way&apos;,
);</pre>
	
	<pre class="hidden code-context">// NOTE We keep named function here to leverage this in the `compose` function,
// and later on in the validations scripts.

/* eslint-disable prefer-arrow-callback */


/* ---------- Internals ---------- */

function namedAs(value, fn) {
  Object.defineProperty(fn, &apos;name&apos;, { value });
  return fn;
}


// NOTE This file is loaded by gitbook&apos;s exercises plugin. When it does, there&apos;s an
// `assert` function available in the global scope.

/* eslint-disable no-undef, global-require */
if (typeof assert !== &apos;function&apos; &amp;&amp; typeof require === &apos;function&apos;) {
  global.assert = require(&apos;assert&apos;);
}

assert.arrayEqual = function assertArrayEqual(actual, expected, message = &apos;arrayEqual&apos;) {
  if (actual.length !== expected.length) {
    throw new Error(message);
  }

  for (let i = 0; i &lt; expected.length; i += 1) {
    if (expected[i] !== actual[i]) {
      throw new Error(message);
    }
  }
};
/* eslint-enable no-undef, global-require */


function inspect(x) {
  if (x &amp;&amp; typeof x.inspect === &apos;function&apos;) {
    return x.inspect();
  }

  function inspectFn(f) {
    return f.name ? f.name : f.toString();
  }

  function inspectTerm(t) {
    switch (typeof t) {
      case &apos;string&apos;:
        return `&apos;${t}&apos;`;
      case &apos;object&apos;: {
        const ts = Object.keys(t).map(k =&gt; [k, inspect(t[k])]);
        return `{${ts.map(kv =&gt; kv.join(&apos;: &apos;)).join(&apos;, &apos;)}}`;
      }
      default:
        return String(t);
    }
  }

  function inspectArgs(args) {
    return Array.isArray(args) ? `[${args.map(inspect).join(&apos;, &apos;)}]` : inspectTerm(args);
  }

  return (typeof x === &apos;function&apos;) ? inspectFn(x) : inspectArgs(x);
}


/* eslint-disable no-param-reassign */
function withSpyOn(prop, obj, fn) {
  const orig = obj[prop];
  let called = false;
  obj[prop] = function spy(...args) {
    called = true;
    return orig.call(this, ...args);
  };
  fn();
  obj[prop] = orig;
  return called;
}
/* eslint-enable no-param-reassign */


const typeMismatch = (src, got, fn) =&gt; `Type Mismatch in function &apos;${fn}&apos;

        ${fn} :: ${got}

      instead of

        ${fn} :: ${src}`;


const capitalize = s =&gt; `${s[0].toUpperCase()}${s.substring(1)}`;


const ordinal = (i) =&gt; {
  switch (i) {
    case 1:
      return &apos;1st&apos;;
    case 2:
      return &apos;2nd&apos;;
    case 3:
      return &apos;3rd&apos;;
    default:
      return `${i}th`; // NOTE won&apos;t get any much bigger ...
  }
};

const getType = (x) =&gt; {
  if (x === null) {
    return &apos;Null&apos;;
  }

  if (typeof x === &apos;undefined&apos;) {
    return &apos;()&apos;;
  }

  if (Array.isArray(x)) {
    return `[${x[0] ? getType(x[0]) : &apos;?&apos;}]`;
  }

  if (typeof x.getType === &apos;function&apos;) {
    return x.getType();
  }

  if (x.constructor &amp;&amp; x.constructor.name) {
    return x.constructor.name;
  }

  return capitalize(typeof x);
};


/* ---------- Essential FP Functions ---------- */

// NOTE A slightly pumped up version of `curry` which also keeps track of
// whether a function was called partially or with all its arguments at once.
// This is useful to provide insights during validation of exercises.
function curry(fn) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;function -&gt; ?&apos;, [getType(fn), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;curry&apos;),
  );

  const arity = fn.length;

  return namedAs(fn.name, function $curry(...args) {
    $curry.partially = this &amp;&amp; this.partially;

    if (args.length &lt; arity) {
      return namedAs(fn.name, $curry.bind({ partially: true }, ...args));
    }

    return fn.call(this || { partially: false }, ...args);
  });
}


// NOTE A slightly pumped up version of `compose` which also keeps track of the chain
// of callees. In the end, a function created with `compose` holds a `callees` variable
// with the list of all the callees&apos; names.
// This is useful to provide insights during validation of exercises
function compose(...fns) {
  const n = fns.length;

  return function $compose(...args) {
    $compose.callees = [];

    let $args = args;

    for (let i = n - 1; i &gt;= 0; i -= 1) {
      const fn = fns[i];

      assert(
        typeof fn === &apos;function&apos;,
        `Invalid Composition: ${ordinal(n - i)} element in a composition isn&apos;t a function`,
      );

      $compose.callees.push(fn.name);
      $args = [fn.call(null, ...$args)];
    }

    return $args[0];
  };
}


/* ---------- Algebraic Data Structures ---------- */

class Either {
  static of(x) {
    return new Right(x); // eslint-disable-line no-use-before-define
  }

  constructor(x) {
    this.$value = x;
  }
}


class Left extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return true;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return false;
  }

  ap() {
    return this;
  }

  chain() {
    return this;
  }

  inspect() {
    return `Left(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ${getType(this.$value)} ?)`;
  }

  join() {
    return this;
  }

  map() {
    return this;
  }

  sequence(of) {
    return of(this);
  }

  traverse(of, fn) {
    return of(this);
  }
}


class Right extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return false;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return true;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return fn(this.$value);
  }

  inspect() {
    return `Right(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ? ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Either.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    fn(this.$value).map(Either.of);
  }
}


class Identity {
  static of(x) {
    return new Identity(x);
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `Identity(${inspect(this.$value)})`;
  }

  getType() {
    return `(Identity ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Identity.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return fn(this.$value).map(Identity.of);
  }
}

class IO {
  static of(x) {
    return new IO(() =&gt; x);
  }

  constructor(io) {
    assert(
      typeof io === &apos;function&apos;,
      &apos;invalid `io` operation given to IO constructor. Use `IO.of` if you want to lift a value in a default minimal IO context.&apos;,
    );

    this.unsafePerformIO = io;
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `IO(${inspect(this.unsafePerformIO())})`;
  }

  getType() {
    return `(IO ${getType(this.unsafePerformIO())})`;
  }


  join() {
    return this.unsafePerformIO();
  }

  map(fn) {
    return new IO(compose(fn, this.unsafePerformIO));
  }
}


class Map {
  constructor(x) {
    assert(
      typeof x === &apos;object&apos; &amp;&amp; x !== null,
      &apos;tried to create `Map` with non object-like&apos;,
    );

    this.$value = x;
  }

  inspect() {
    return `Map(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[Object.keys(this.$value)[0]];

    return `(Map String ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  insert(k, v) {
    const singleton = {};
    singleton[k] = v;
    return new Map(Object.assign({}, this.$value, singleton));
  }

  reduce(fn, zero) {
    return this.reduceWithKeys((acc, _, k) =&gt; fn(acc, k), zero);
  }

  reduceWithKeys(fn, zero) {
    return Object.keys(this.$value)
      .reduce((acc, k) =&gt; fn(acc, this.$value[k], k), zero);
  }

  map(fn) {
    return new Map(this.reduceWithKeys((obj, v, k) =&gt; {
      obj[k] = fn(v); // eslint-disable-line no-param-reassign
      return obj;
    }, {}));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.reduceWithKeys(
      (f, a, k) =&gt; fn(a).map(b =&gt; m =&gt; m.insert(k, b)).ap(f),
      of(new Map({})),
    );
  }
}


class List {
  static of(x) {
    return new List([x]);
  }

  constructor(xs) {
    assert(
      Array.isArray(xs),
      &apos;tried to create `List` from non-array&apos;,
    );

    this.$value = xs;
  }

  concat(x) {
    return new List(this.$value.concat(x));
  }

  inspect() {
    return `List(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[0];

    return `(List ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  map(fn) {
    return new List(this.$value.map(fn));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.$value.reduce(
      (f, a) =&gt; fn(a).map(b =&gt; bs =&gt; bs.concat(b)).ap(f),
      of(new List([])),
    );
  }
}


class Maybe {
  static of(x) {
    return new Maybe(x);
  }

  get isNothing() {
    return this.$value === null || this.$value === undefined;
  }

  get isJust() {
    return !this.isNothing;
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return this.isNothing ? this : f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return this.isNothing ? &apos;Nothing&apos; : `Just(${inspect(this.$value)})`;
  }

  getType() {
    return `(Maybe ${this.isJust ? getType(this.$value) : &apos;?&apos;})`;
  }

  join() {
    return this.isNothing ? this : this.$value;
  }

  map(fn) {
    return this.isNothing ? this : Maybe.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.isNothing ? of(this) : fn(this.$value).map(Maybe.of);
  }
}


class Task {
  constructor(fork) {
    assert(
      typeof fork === &apos;function&apos;,
      &apos;invalid `fork` operation given to Task constructor. Use `Task.of` if you want to lift a value in a default minimal Task context.&apos;,
    );

    this.fork = fork;
  }

  static of(x) {
    return new Task((_, resolve) =&gt; resolve(x));
  }

  static rejected(x) {
    return new Task((reject, _) =&gt; reject(x));
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, x =&gt; fn(x).fork(reject, resolve)));
  }

  inspect() { // eslint-disable-line class-methods-use-this
    return &apos;Task(?)&apos;;
  }

  getType() { // eslint-disable-line class-methods-use-this
    return &apos;(Task ? ?)&apos;;
  }

  join() {
    return this.chain(x =&gt; x);
  }

  map(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, compose(resolve, fn)));
  }
}

// In nodejs the existance of a class method named `inspect` will trigger a deprecation warning
// when passing an instance to `console.log`:
// `(node:3845) [DEP0079] DeprecationWarning: Custom inspection function on Objects via .inspect() is deprecated`
// The solution is to alias the existing inspect method with the special inspect symbol exported by node
if (typeof module !== &apos;undefined&apos; &amp;&amp; typeof this !== &apos;undefined&apos; &amp;&amp; this.module !== module) {
  const customInspect = require(&apos;util&apos;).inspect.custom;
  const assignCustomInspect = it =&gt; it.prototype[customInspect] = it.prototype.inspect;
  [Left, Right, Identity, IO, Map, List, Maybe, Task].forEach(assignCustomInspect);
}

const identity = function identity(x) { return x; };

const either = curry(function either(f, g, e) {
  if (e.isLeft) {
    return f(e.$value);
  }

  return g(e.$value);
});

const left = function left(x) { return new Left(x); };

const maybe = curry(function maybe(v, f, m) {
  if (m.isNothing) {
    return v;
  }

  return f(m.$value);
});

const nothing = Maybe.of(null);

const reject = function reject(x) { return Task.rejected(x); };

const chain = curry(function chain(fn, m) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m a&apos;, [getType(fn), getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;chain&apos;),
  );

  return m.chain(fn);
});

const join = function join(m) {
  assert(
    typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; m (m a) -&gt; m a&apos;, [getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;join&apos;),
  );

  return m.join();
};

const map = curry(function map(fn, f) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof f.map === &apos;function&apos;,
    typeMismatch(&apos;Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b&apos;, [getType(fn), getType(f), &apos;f b&apos;].join(&apos; -&gt; &apos;), &apos;map&apos;),
  );

  return f.map(fn);
});

const sequence = curry(function sequence(of, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof x.sequence === &apos;function&apos;,
    typeMismatch(&apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; t (f a) -&gt; f (t a)&apos;, [getType(of), getType(x), &apos;f (t a)&apos;].join(&apos; -&gt; &apos;), &apos;sequence&apos;),
  );

  return x.sequence(of);
});

const traverse = curry(function traverse(of, fn, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof fn === &apos;function&apos; &amp;&amp; typeof x.traverse === &apos;function&apos;,
    typeMismatch(
      &apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)&apos;,
      [getType(of), getType(fn), getType(x), &apos;f (t b)&apos;].join(&apos; -&gt; &apos;),
      &apos;traverse&apos;,
    ),
  );

  return x.traverse(of, fn);
});

const unsafePerformIO = function unsafePerformIO(io) {
  assert(
    io instanceof IO,
    typeMismatch(&apos;IO a&apos;, getType(io), &apos;unsafePerformIO&apos;),
  );

  return io.unsafePerformIO();
};

const liftA2 = curry(function liftA2(fn, a1, a2) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2);
});

const liftA3 = curry(function liftA3(fn, a1, a2, a3) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;
      &amp;&amp; typeof a3.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2).ap(a3);
});

const always = curry(function always(a, b) { return a; });


/* ---------- Pointfree Classic Utilities ---------- */

const append = curry(function append(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return b.concat(a);
});

const add = curry(function add(a, b) {
  assert(
    typeof a === &apos;number&apos; &amp;&amp; typeof b === &apos;number&apos;,
    typeMismatch(&apos;Number -&gt; Number -&gt; Number&apos;, [getType(a), getType(b), &apos;Number&apos;].join(&apos; -&gt; &apos;), &apos;add&apos;),
  );

  return a + b;
});

const concat = curry(function concat(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return a.concat(b);
});

const eq = curry(function eq(a, b) {
  assert(
    getType(a) === getType(b),
    typeMismatch(&apos;a -&gt; a -&gt; Boolean&apos;, [getType(a), getType(b), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), eq),
  );

  return a === b;
});

const filter = curry(function filter(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; Boolean) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;filter&apos;),
  );

  return xs.filter(fn);
});

const flip = curry(function flip(fn, a, b) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;(a -&gt; b) -&gt; (b -&gt; a)&apos;, [getType(fn), &apos;(b -&gt; a)&apos;].join(&apos; -&gt; &apos;), &apos;flip&apos;),
  );

  return fn(b, a);
});

const forEach = curry(function forEach(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; ()) -&gt; [a] -&gt; ()&apos;, [getType(fn), getType(xs), &apos;()&apos;].join(&apos; -&gt; &apos;), &apos;forEach&apos;),
  );

  xs.forEach(fn);
});

const intercalate = curry(function intercalate(str, xs) {
  assert(
    typeof str === &apos;string&apos; &amp;&amp; Array.isArray(xs) &amp;&amp; (xs.length === 0 || typeof xs[0] === &apos;string&apos;),
    typeMismatch(&apos;String -&gt; [String] -&gt; String&apos;, [getType(str), getType(xs), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;intercalate&apos;),
  );

  return xs.join(str);
});

const head = function head(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;head&apos;),
  );

  return xs[0];
};

const last = function last(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;last&apos;),
  );

  return xs[xs.length - 1];
};

const match = curry(function match(re, str) {
  assert(
    re instanceof RegExp &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;RegExp -&gt; String -&gt; Boolean&apos;, [getType(re), getType(str), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), &apos;match&apos;),
  );

  return re.test(str);
});

const prop = curry(function prop(p, obj) {
  assert(
    typeof p === &apos;string&apos; &amp;&amp; typeof obj === &apos;object&apos; &amp;&amp; obj !== null,
    typeMismatch(&apos;String -&gt; Object -&gt; a&apos;, [getType(p), getType(obj), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;prop&apos;),
  );

  return obj[p];
});

const reduce = curry(function reduce(fn, zero, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b&apos;, [getType(fn), getType(zero), getType(xs), &apos;b&apos;].join(&apos; -&gt; &apos;), &apos;reduce&apos;),
  );

  return xs.reduce(
    function $reduceIterator($acc, $x) { return fn($acc, $x); },
    zero,
  );
});

const safeHead = namedAs(&apos;safeHead&apos;, compose(Maybe.of, head));

const safeProp = curry(function safeProp(p, obj) { return Maybe.of(prop(p, obj)); });

const sortBy = curry(function sortBy(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), &apos;[a]&apos;].join(&apos; -&gt; &apos;), &apos;sortBy&apos;),
  );

  return xs.sort((a, b) =&gt; {
    if (fn(a) === fn(b)) {
      return 0;
    }

    return fn(a) &gt; fn(b) ? 1 : -1;
  });
});

const split = curry(function split(s, str) {
  assert(
    typeof s === &apos;string&apos; &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; [String]&apos;, [getType(s), getType(str), &apos;[String]&apos;].join(&apos; -&gt; &apos;), &apos;split&apos;),
  );

  return str.split(s);
});

const take = curry(function take(n, xs) {
  assert(
    typeof n === &apos;number&apos; &amp;&amp; (Array.isArray(xs) || typeof xs === &apos;string&apos;),
    typeMismatch(&apos;Number -&gt; [a] -&gt; [a]&apos;, [getType(n), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;take&apos;),
  );

  return xs.slice(0, n);
});

const toLowerCase = function toLowerCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toLowerCase();
};

const toUpperCase = function toUpperCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toUpperCase();
};


/* ---------- Chapter 4 ---------- */

const keepHighest = function keepHighest(x, y) {
  try {
    keepHighest.calledBy = keepHighest.caller;
  } catch (err) {
    // NOTE node.js runs in strict mode and prohibit the usage of &apos;.caller&apos;
    // There&apos;s a ugly hack to retrieve the caller from stack trace.
    const [, caller] = /at (\S+)/.exec(err.stack.split(&apos;\n&apos;)[2]);

    keepHighest.calledBy = namedAs(caller, () =&gt; {});
  }

  return x &gt;= y ? x : y;
};


/* ---------- Chapter 5 ---------- */

const cars = [{
  name: &apos;Ferrari FF&apos;,
  horsepower: 660,
  dollar_value: 700000,
  in_stock: true,
}, {
  name: &apos;Spyker C12 Zagato&apos;,
  horsepower: 650,
  dollar_value: 648000,
  in_stock: false,
}, {
  name: &apos;Jaguar XKR-S&apos;,
  horsepower: 550,
  dollar_value: 132000,
  in_stock: true,
}, {
  name: &apos;Audi R8&apos;,
  horsepower: 525,
  dollar_value: 114200,
  in_stock: false,
}, {
  name: &apos;Aston Martin One-77&apos;,
  horsepower: 750,
  dollar_value: 1850000,
  in_stock: true,
}, {
  name: &apos;Pagani Huayra&apos;,
  horsepower: 700,
  dollar_value: 1300000,
  in_stock: false,
}];

const average = function average(xs) {
  return xs.reduce(add, 0) / xs.length;
};


/* ---------- Chapter 8 ---------- */

const albert = {
  id: 1,
  active: true,
  name: &apos;Albert&apos;,
  address: {
    street: {
      number: 22,
      name: &apos;Walnut St&apos;,
    },
  },
};

const gary = {
  id: 2,
  active: false,
  name: &apos;Gary&apos;,
  address: {
    street: {
      number: 14,
    },
  },
};

const theresa = {
  id: 3,
  active: true,
  name: &apos;Theresa&apos;,
};

const yi = { id: 4, name: &apos;Yi&apos;, active: true };

const showWelcome = namedAs(&apos;showWelcome&apos;, compose(concat(&apos;Welcome &apos;), prop(&apos;name&apos;)));

const checkActive = function checkActive(user) {
  return user.active
    ? Either.of(user)
    : left(&apos;Your account is not active&apos;);
};

const save = function save(user) {
  return new IO(() =&gt; Object.assign({}, user, { saved: true }));
};

const validateUser = curry(function validateUser(validate, user) {
  return validate(user).map(_ =&gt; user); // eslint-disable-line no-unused-vars
});


/* ---------- Chapter 9 ---------- */

const getFile = IO.of(&apos;/home/mostly-adequate/ch09.md&apos;);

const pureLog = function pureLog(str) { return new IO(() =&gt; { console.log(str); return str; }); };

const addToMailingList = function addToMailingList(email) { return IO.of([email]); };

const emailBlast = function emailBlast(list) { return IO.of(list.join(&apos;,&apos;)); };

const validateEmail = function validateEmail(x) {
  return /\S+@\S+\.\S+/.test(x)
    ? Either.of(x)
    : left(&apos;invalid email&apos;);
};


/* ---------- Chapter 10 ---------- */

const localStorage = { player1: albert, player2: theresa };

const game = curry(function game(p1, p2) { return `${p1.name} vs ${p2.name}`; });

const getFromCache = function getFromCache(x) { return new IO(() =&gt; localStorage[x]); };


/* ---------- Chapter 11 ---------- */

const findUserById = function findUserById(id) {
  switch (id) {
    case 1:
      return Task.of(Either.of(albert));

    case 2:
      return Task.of(Either.of(gary));

    case 3:
      return Task.of(Either.of(theresa));

    default:
      return Task.of(left(&apos;not found&apos;));
  }
};

const eitherToTask = namedAs(&apos;eitherToTask&apos;, either(Task.rejected, Task.of));


/* ---------- Chapter 12 ---------- */

const httpGet = function httpGet(route) { return Task.of(`json for ${route}`); };

const routes = new Map({
  &apos;/&apos;: &apos;/&apos;,
  &apos;/about&apos;: &apos;/about&apos;,
});

const validate = function validate(player) {
  return player.name
    ? Either.of(player)
    : left(&apos;must have name&apos;);
};

const readdir = function readdir(dir) {
  return Task.of([&apos;file1&apos;, &apos;file2&apos;, &apos;file3&apos;]);
};

const readfile = curry(function readfile(encoding, file) {
  return Task.of(`content of ${file} (${encoding})`);
});


/* ---------- Exports ---------- */

if (typeof module === &apos;object&apos;) {
  module.exports = {
    // Utils
    withSpyOn,

    // Essential FP helpers
    always,
    compose,
    curry,
    either,
    identity,
    inspect,
    left,
    liftA2,
    liftA3,
    maybe,
    nothing,
    reject,

    // Algebraic Data Structures
    Either,
    IO,
    Identity,
    Left,
    List,
    Map,
    Maybe,
    Right,
    Task,

    // Currified version of &apos;standard&apos; functions
    append,
    add,
    chain,
    concat,
    eq,
    filter,
    flip,
    forEach,
    head,
    intercalate,
    join,
    last,
    map,
    match,
    prop,
    reduce,
    safeHead,
    safeProp,
    sequence,
    sortBy,
    split,
    take,
    toLowerCase,
    toUpperCase,
    traverse,
    unsafePerformIO,

    // Chapter 04
    keepHighest,

    // Chapter 05
    cars,
    average,

    // Chapter 08
    albert,
    gary,
    theresa,
    yi,
    showWelcome,
    checkActive,
    save,
    validateUser,

    // Chapter 09
    getFile,
    pureLog,
    addToMailingList,
    emailBlast,
    validateEmail,

    // Chapter 10
    localStorage,
    getFromCache,
    game,

    // Chapter 11
    findUserById,
    eitherToTask,

    // Chapter 12
    httpGet,
    routes,
    validate,
    readdir,
    readfile,
  };
}</pre>
	

	<div class="buttons">
	    <a href="#" class="button size-2 action-submit">Submit</a>
	    <a href="#" class="button size-2 action-solution">Solution</a>
	</div>
</div>  </p>
<hr>
<p>Given the following helper functions:</p>
<pre><code class="lang-js"><span class="hljs-comment">// showWelcome :: User -&gt; String</span>
<span class="hljs-keyword">const</span> showWelcome = compose(append(<span class="hljs-string">&apos;Welcome &apos;</span>), prop(<span class="hljs-string">&apos;name&apos;</span>));

<span class="hljs-comment">// checkActive :: User -&gt; Either String User</span>
<span class="hljs-keyword">const</span> checkActive = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkActive</span>(<span class="hljs-params">user</span>) </span>{
  <span class="hljs-keyword">return</span> user.active
    ? Either.of(user)
    : left(<span class="hljs-string">&apos;Your account is not active&apos;</span>);
};
</code></pre>
<p><div class="exercise">
	<div class="header">Exercise</div>
	<div class="alert alert-success">
	    <b>Correct!</b>
	</div>

	<div class="alert alert-danger error-message">
	    <b>False!</b>
	</div>

	<div class="message">
	  
Write a function that uses `checkActive` and `showWelcome` to grant access or return the error.


	</div>
	<div class="editor" style="height: 20px">// eitherWelcome :: User -&gt; Either String String
const eitherWelcome = undefined;</div>

	<pre class="hidden code-solution">const eitherWelcome = compose(map(showWelcome), checkActive);</pre>
	<pre class="hidden code-validation">/* globals eitherWelcome */

if (!(eitherWelcome(gary) instanceof Either) &amp;&amp; eitherWelcome.callees &amp;&amp; eitherWelcome.callees[0] === &apos;checkActive&apos; &amp;&amp; eitherWelcome.callees[1] === &apos;showWelcome&apos;) {
  throw new Error(&apos;The function gives incorrect results; hint: look carefully at the signatures of `checkActive` and `showWelcome`!&apos;);
}

assert(
  eitherWelcome(gary).$value === &apos;Your account is not active&apos;,
  &apos;The function gives incorrect results.&apos;,
);

assert(
  eitherWelcome(theresa).$value === &apos;Welcome Theresa&apos;,
  &apos;The function gives incorrect results.&apos;,
);

assert.arrayEqual(
  eitherWelcome.callees || [],
  [&apos;checkActive&apos;, &apos;map&apos;],
  &apos;The answer is incorrect; hint: you can compose `checkActive` with `showWelcome` in a declarative way!&apos;,
);</pre>
	
	<pre class="hidden code-context">// NOTE We keep named function here to leverage this in the `compose` function,
// and later on in the validations scripts.

/* eslint-disable prefer-arrow-callback */


/* ---------- Internals ---------- */

function namedAs(value, fn) {
  Object.defineProperty(fn, &apos;name&apos;, { value });
  return fn;
}


// NOTE This file is loaded by gitbook&apos;s exercises plugin. When it does, there&apos;s an
// `assert` function available in the global scope.

/* eslint-disable no-undef, global-require */
if (typeof assert !== &apos;function&apos; &amp;&amp; typeof require === &apos;function&apos;) {
  global.assert = require(&apos;assert&apos;);
}

assert.arrayEqual = function assertArrayEqual(actual, expected, message = &apos;arrayEqual&apos;) {
  if (actual.length !== expected.length) {
    throw new Error(message);
  }

  for (let i = 0; i &lt; expected.length; i += 1) {
    if (expected[i] !== actual[i]) {
      throw new Error(message);
    }
  }
};
/* eslint-enable no-undef, global-require */


function inspect(x) {
  if (x &amp;&amp; typeof x.inspect === &apos;function&apos;) {
    return x.inspect();
  }

  function inspectFn(f) {
    return f.name ? f.name : f.toString();
  }

  function inspectTerm(t) {
    switch (typeof t) {
      case &apos;string&apos;:
        return `&apos;${t}&apos;`;
      case &apos;object&apos;: {
        const ts = Object.keys(t).map(k =&gt; [k, inspect(t[k])]);
        return `{${ts.map(kv =&gt; kv.join(&apos;: &apos;)).join(&apos;, &apos;)}}`;
      }
      default:
        return String(t);
    }
  }

  function inspectArgs(args) {
    return Array.isArray(args) ? `[${args.map(inspect).join(&apos;, &apos;)}]` : inspectTerm(args);
  }

  return (typeof x === &apos;function&apos;) ? inspectFn(x) : inspectArgs(x);
}


/* eslint-disable no-param-reassign */
function withSpyOn(prop, obj, fn) {
  const orig = obj[prop];
  let called = false;
  obj[prop] = function spy(...args) {
    called = true;
    return orig.call(this, ...args);
  };
  fn();
  obj[prop] = orig;
  return called;
}
/* eslint-enable no-param-reassign */


const typeMismatch = (src, got, fn) =&gt; `Type Mismatch in function &apos;${fn}&apos;

        ${fn} :: ${got}

      instead of

        ${fn} :: ${src}`;


const capitalize = s =&gt; `${s[0].toUpperCase()}${s.substring(1)}`;


const ordinal = (i) =&gt; {
  switch (i) {
    case 1:
      return &apos;1st&apos;;
    case 2:
      return &apos;2nd&apos;;
    case 3:
      return &apos;3rd&apos;;
    default:
      return `${i}th`; // NOTE won&apos;t get any much bigger ...
  }
};

const getType = (x) =&gt; {
  if (x === null) {
    return &apos;Null&apos;;
  }

  if (typeof x === &apos;undefined&apos;) {
    return &apos;()&apos;;
  }

  if (Array.isArray(x)) {
    return `[${x[0] ? getType(x[0]) : &apos;?&apos;}]`;
  }

  if (typeof x.getType === &apos;function&apos;) {
    return x.getType();
  }

  if (x.constructor &amp;&amp; x.constructor.name) {
    return x.constructor.name;
  }

  return capitalize(typeof x);
};


/* ---------- Essential FP Functions ---------- */

// NOTE A slightly pumped up version of `curry` which also keeps track of
// whether a function was called partially or with all its arguments at once.
// This is useful to provide insights during validation of exercises.
function curry(fn) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;function -&gt; ?&apos;, [getType(fn), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;curry&apos;),
  );

  const arity = fn.length;

  return namedAs(fn.name, function $curry(...args) {
    $curry.partially = this &amp;&amp; this.partially;

    if (args.length &lt; arity) {
      return namedAs(fn.name, $curry.bind({ partially: true }, ...args));
    }

    return fn.call(this || { partially: false }, ...args);
  });
}


// NOTE A slightly pumped up version of `compose` which also keeps track of the chain
// of callees. In the end, a function created with `compose` holds a `callees` variable
// with the list of all the callees&apos; names.
// This is useful to provide insights during validation of exercises
function compose(...fns) {
  const n = fns.length;

  return function $compose(...args) {
    $compose.callees = [];

    let $args = args;

    for (let i = n - 1; i &gt;= 0; i -= 1) {
      const fn = fns[i];

      assert(
        typeof fn === &apos;function&apos;,
        `Invalid Composition: ${ordinal(n - i)} element in a composition isn&apos;t a function`,
      );

      $compose.callees.push(fn.name);
      $args = [fn.call(null, ...$args)];
    }

    return $args[0];
  };
}


/* ---------- Algebraic Data Structures ---------- */

class Either {
  static of(x) {
    return new Right(x); // eslint-disable-line no-use-before-define
  }

  constructor(x) {
    this.$value = x;
  }
}


class Left extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return true;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return false;
  }

  ap() {
    return this;
  }

  chain() {
    return this;
  }

  inspect() {
    return `Left(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ${getType(this.$value)} ?)`;
  }

  join() {
    return this;
  }

  map() {
    return this;
  }

  sequence(of) {
    return of(this);
  }

  traverse(of, fn) {
    return of(this);
  }
}


class Right extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return false;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return true;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return fn(this.$value);
  }

  inspect() {
    return `Right(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ? ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Either.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    fn(this.$value).map(Either.of);
  }
}


class Identity {
  static of(x) {
    return new Identity(x);
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `Identity(${inspect(this.$value)})`;
  }

  getType() {
    return `(Identity ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Identity.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return fn(this.$value).map(Identity.of);
  }
}

class IO {
  static of(x) {
    return new IO(() =&gt; x);
  }

  constructor(io) {
    assert(
      typeof io === &apos;function&apos;,
      &apos;invalid `io` operation given to IO constructor. Use `IO.of` if you want to lift a value in a default minimal IO context.&apos;,
    );

    this.unsafePerformIO = io;
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `IO(${inspect(this.unsafePerformIO())})`;
  }

  getType() {
    return `(IO ${getType(this.unsafePerformIO())})`;
  }


  join() {
    return this.unsafePerformIO();
  }

  map(fn) {
    return new IO(compose(fn, this.unsafePerformIO));
  }
}


class Map {
  constructor(x) {
    assert(
      typeof x === &apos;object&apos; &amp;&amp; x !== null,
      &apos;tried to create `Map` with non object-like&apos;,
    );

    this.$value = x;
  }

  inspect() {
    return `Map(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[Object.keys(this.$value)[0]];

    return `(Map String ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  insert(k, v) {
    const singleton = {};
    singleton[k] = v;
    return new Map(Object.assign({}, this.$value, singleton));
  }

  reduce(fn, zero) {
    return this.reduceWithKeys((acc, _, k) =&gt; fn(acc, k), zero);
  }

  reduceWithKeys(fn, zero) {
    return Object.keys(this.$value)
      .reduce((acc, k) =&gt; fn(acc, this.$value[k], k), zero);
  }

  map(fn) {
    return new Map(this.reduceWithKeys((obj, v, k) =&gt; {
      obj[k] = fn(v); // eslint-disable-line no-param-reassign
      return obj;
    }, {}));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.reduceWithKeys(
      (f, a, k) =&gt; fn(a).map(b =&gt; m =&gt; m.insert(k, b)).ap(f),
      of(new Map({})),
    );
  }
}


class List {
  static of(x) {
    return new List([x]);
  }

  constructor(xs) {
    assert(
      Array.isArray(xs),
      &apos;tried to create `List` from non-array&apos;,
    );

    this.$value = xs;
  }

  concat(x) {
    return new List(this.$value.concat(x));
  }

  inspect() {
    return `List(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[0];

    return `(List ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  map(fn) {
    return new List(this.$value.map(fn));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.$value.reduce(
      (f, a) =&gt; fn(a).map(b =&gt; bs =&gt; bs.concat(b)).ap(f),
      of(new List([])),
    );
  }
}


class Maybe {
  static of(x) {
    return new Maybe(x);
  }

  get isNothing() {
    return this.$value === null || this.$value === undefined;
  }

  get isJust() {
    return !this.isNothing;
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return this.isNothing ? this : f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return this.isNothing ? &apos;Nothing&apos; : `Just(${inspect(this.$value)})`;
  }

  getType() {
    return `(Maybe ${this.isJust ? getType(this.$value) : &apos;?&apos;})`;
  }

  join() {
    return this.isNothing ? this : this.$value;
  }

  map(fn) {
    return this.isNothing ? this : Maybe.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.isNothing ? of(this) : fn(this.$value).map(Maybe.of);
  }
}


class Task {
  constructor(fork) {
    assert(
      typeof fork === &apos;function&apos;,
      &apos;invalid `fork` operation given to Task constructor. Use `Task.of` if you want to lift a value in a default minimal Task context.&apos;,
    );

    this.fork = fork;
  }

  static of(x) {
    return new Task((_, resolve) =&gt; resolve(x));
  }

  static rejected(x) {
    return new Task((reject, _) =&gt; reject(x));
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, x =&gt; fn(x).fork(reject, resolve)));
  }

  inspect() { // eslint-disable-line class-methods-use-this
    return &apos;Task(?)&apos;;
  }

  getType() { // eslint-disable-line class-methods-use-this
    return &apos;(Task ? ?)&apos;;
  }

  join() {
    return this.chain(x =&gt; x);
  }

  map(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, compose(resolve, fn)));
  }
}

// In nodejs the existance of a class method named `inspect` will trigger a deprecation warning
// when passing an instance to `console.log`:
// `(node:3845) [DEP0079] DeprecationWarning: Custom inspection function on Objects via .inspect() is deprecated`
// The solution is to alias the existing inspect method with the special inspect symbol exported by node
if (typeof module !== &apos;undefined&apos; &amp;&amp; typeof this !== &apos;undefined&apos; &amp;&amp; this.module !== module) {
  const customInspect = require(&apos;util&apos;).inspect.custom;
  const assignCustomInspect = it =&gt; it.prototype[customInspect] = it.prototype.inspect;
  [Left, Right, Identity, IO, Map, List, Maybe, Task].forEach(assignCustomInspect);
}

const identity = function identity(x) { return x; };

const either = curry(function either(f, g, e) {
  if (e.isLeft) {
    return f(e.$value);
  }

  return g(e.$value);
});

const left = function left(x) { return new Left(x); };

const maybe = curry(function maybe(v, f, m) {
  if (m.isNothing) {
    return v;
  }

  return f(m.$value);
});

const nothing = Maybe.of(null);

const reject = function reject(x) { return Task.rejected(x); };

const chain = curry(function chain(fn, m) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m a&apos;, [getType(fn), getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;chain&apos;),
  );

  return m.chain(fn);
});

const join = function join(m) {
  assert(
    typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; m (m a) -&gt; m a&apos;, [getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;join&apos;),
  );

  return m.join();
};

const map = curry(function map(fn, f) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof f.map === &apos;function&apos;,
    typeMismatch(&apos;Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b&apos;, [getType(fn), getType(f), &apos;f b&apos;].join(&apos; -&gt; &apos;), &apos;map&apos;),
  );

  return f.map(fn);
});

const sequence = curry(function sequence(of, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof x.sequence === &apos;function&apos;,
    typeMismatch(&apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; t (f a) -&gt; f (t a)&apos;, [getType(of), getType(x), &apos;f (t a)&apos;].join(&apos; -&gt; &apos;), &apos;sequence&apos;),
  );

  return x.sequence(of);
});

const traverse = curry(function traverse(of, fn, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof fn === &apos;function&apos; &amp;&amp; typeof x.traverse === &apos;function&apos;,
    typeMismatch(
      &apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)&apos;,
      [getType(of), getType(fn), getType(x), &apos;f (t b)&apos;].join(&apos; -&gt; &apos;),
      &apos;traverse&apos;,
    ),
  );

  return x.traverse(of, fn);
});

const unsafePerformIO = function unsafePerformIO(io) {
  assert(
    io instanceof IO,
    typeMismatch(&apos;IO a&apos;, getType(io), &apos;unsafePerformIO&apos;),
  );

  return io.unsafePerformIO();
};

const liftA2 = curry(function liftA2(fn, a1, a2) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2);
});

const liftA3 = curry(function liftA3(fn, a1, a2, a3) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;
      &amp;&amp; typeof a3.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2).ap(a3);
});

const always = curry(function always(a, b) { return a; });


/* ---------- Pointfree Classic Utilities ---------- */

const append = curry(function append(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return b.concat(a);
});

const add = curry(function add(a, b) {
  assert(
    typeof a === &apos;number&apos; &amp;&amp; typeof b === &apos;number&apos;,
    typeMismatch(&apos;Number -&gt; Number -&gt; Number&apos;, [getType(a), getType(b), &apos;Number&apos;].join(&apos; -&gt; &apos;), &apos;add&apos;),
  );

  return a + b;
});

const concat = curry(function concat(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return a.concat(b);
});

const eq = curry(function eq(a, b) {
  assert(
    getType(a) === getType(b),
    typeMismatch(&apos;a -&gt; a -&gt; Boolean&apos;, [getType(a), getType(b), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), eq),
  );

  return a === b;
});

const filter = curry(function filter(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; Boolean) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;filter&apos;),
  );

  return xs.filter(fn);
});

const flip = curry(function flip(fn, a, b) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;(a -&gt; b) -&gt; (b -&gt; a)&apos;, [getType(fn), &apos;(b -&gt; a)&apos;].join(&apos; -&gt; &apos;), &apos;flip&apos;),
  );

  return fn(b, a);
});

const forEach = curry(function forEach(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; ()) -&gt; [a] -&gt; ()&apos;, [getType(fn), getType(xs), &apos;()&apos;].join(&apos; -&gt; &apos;), &apos;forEach&apos;),
  );

  xs.forEach(fn);
});

const intercalate = curry(function intercalate(str, xs) {
  assert(
    typeof str === &apos;string&apos; &amp;&amp; Array.isArray(xs) &amp;&amp; (xs.length === 0 || typeof xs[0] === &apos;string&apos;),
    typeMismatch(&apos;String -&gt; [String] -&gt; String&apos;, [getType(str), getType(xs), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;intercalate&apos;),
  );

  return xs.join(str);
});

const head = function head(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;head&apos;),
  );

  return xs[0];
};

const last = function last(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;last&apos;),
  );

  return xs[xs.length - 1];
};

const match = curry(function match(re, str) {
  assert(
    re instanceof RegExp &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;RegExp -&gt; String -&gt; Boolean&apos;, [getType(re), getType(str), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), &apos;match&apos;),
  );

  return re.test(str);
});

const prop = curry(function prop(p, obj) {
  assert(
    typeof p === &apos;string&apos; &amp;&amp; typeof obj === &apos;object&apos; &amp;&amp; obj !== null,
    typeMismatch(&apos;String -&gt; Object -&gt; a&apos;, [getType(p), getType(obj), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;prop&apos;),
  );

  return obj[p];
});

const reduce = curry(function reduce(fn, zero, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b&apos;, [getType(fn), getType(zero), getType(xs), &apos;b&apos;].join(&apos; -&gt; &apos;), &apos;reduce&apos;),
  );

  return xs.reduce(
    function $reduceIterator($acc, $x) { return fn($acc, $x); },
    zero,
  );
});

const safeHead = namedAs(&apos;safeHead&apos;, compose(Maybe.of, head));

const safeProp = curry(function safeProp(p, obj) { return Maybe.of(prop(p, obj)); });

const sortBy = curry(function sortBy(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), &apos;[a]&apos;].join(&apos; -&gt; &apos;), &apos;sortBy&apos;),
  );

  return xs.sort((a, b) =&gt; {
    if (fn(a) === fn(b)) {
      return 0;
    }

    return fn(a) &gt; fn(b) ? 1 : -1;
  });
});

const split = curry(function split(s, str) {
  assert(
    typeof s === &apos;string&apos; &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; [String]&apos;, [getType(s), getType(str), &apos;[String]&apos;].join(&apos; -&gt; &apos;), &apos;split&apos;),
  );

  return str.split(s);
});

const take = curry(function take(n, xs) {
  assert(
    typeof n === &apos;number&apos; &amp;&amp; (Array.isArray(xs) || typeof xs === &apos;string&apos;),
    typeMismatch(&apos;Number -&gt; [a] -&gt; [a]&apos;, [getType(n), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;take&apos;),
  );

  return xs.slice(0, n);
});

const toLowerCase = function toLowerCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toLowerCase();
};

const toUpperCase = function toUpperCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toUpperCase();
};


/* ---------- Chapter 4 ---------- */

const keepHighest = function keepHighest(x, y) {
  try {
    keepHighest.calledBy = keepHighest.caller;
  } catch (err) {
    // NOTE node.js runs in strict mode and prohibit the usage of &apos;.caller&apos;
    // There&apos;s a ugly hack to retrieve the caller from stack trace.
    const [, caller] = /at (\S+)/.exec(err.stack.split(&apos;\n&apos;)[2]);

    keepHighest.calledBy = namedAs(caller, () =&gt; {});
  }

  return x &gt;= y ? x : y;
};


/* ---------- Chapter 5 ---------- */

const cars = [{
  name: &apos;Ferrari FF&apos;,
  horsepower: 660,
  dollar_value: 700000,
  in_stock: true,
}, {
  name: &apos;Spyker C12 Zagato&apos;,
  horsepower: 650,
  dollar_value: 648000,
  in_stock: false,
}, {
  name: &apos;Jaguar XKR-S&apos;,
  horsepower: 550,
  dollar_value: 132000,
  in_stock: true,
}, {
  name: &apos;Audi R8&apos;,
  horsepower: 525,
  dollar_value: 114200,
  in_stock: false,
}, {
  name: &apos;Aston Martin One-77&apos;,
  horsepower: 750,
  dollar_value: 1850000,
  in_stock: true,
}, {
  name: &apos;Pagani Huayra&apos;,
  horsepower: 700,
  dollar_value: 1300000,
  in_stock: false,
}];

const average = function average(xs) {
  return xs.reduce(add, 0) / xs.length;
};


/* ---------- Chapter 8 ---------- */

const albert = {
  id: 1,
  active: true,
  name: &apos;Albert&apos;,
  address: {
    street: {
      number: 22,
      name: &apos;Walnut St&apos;,
    },
  },
};

const gary = {
  id: 2,
  active: false,
  name: &apos;Gary&apos;,
  address: {
    street: {
      number: 14,
    },
  },
};

const theresa = {
  id: 3,
  active: true,
  name: &apos;Theresa&apos;,
};

const yi = { id: 4, name: &apos;Yi&apos;, active: true };

const showWelcome = namedAs(&apos;showWelcome&apos;, compose(concat(&apos;Welcome &apos;), prop(&apos;name&apos;)));

const checkActive = function checkActive(user) {
  return user.active
    ? Either.of(user)
    : left(&apos;Your account is not active&apos;);
};

const save = function save(user) {
  return new IO(() =&gt; Object.assign({}, user, { saved: true }));
};

const validateUser = curry(function validateUser(validate, user) {
  return validate(user).map(_ =&gt; user); // eslint-disable-line no-unused-vars
});


/* ---------- Chapter 9 ---------- */

const getFile = IO.of(&apos;/home/mostly-adequate/ch09.md&apos;);

const pureLog = function pureLog(str) { return new IO(() =&gt; { console.log(str); return str; }); };

const addToMailingList = function addToMailingList(email) { return IO.of([email]); };

const emailBlast = function emailBlast(list) { return IO.of(list.join(&apos;,&apos;)); };

const validateEmail = function validateEmail(x) {
  return /\S+@\S+\.\S+/.test(x)
    ? Either.of(x)
    : left(&apos;invalid email&apos;);
};


/* ---------- Chapter 10 ---------- */

const localStorage = { player1: albert, player2: theresa };

const game = curry(function game(p1, p2) { return `${p1.name} vs ${p2.name}`; });

const getFromCache = function getFromCache(x) { return new IO(() =&gt; localStorage[x]); };


/* ---------- Chapter 11 ---------- */

const findUserById = function findUserById(id) {
  switch (id) {
    case 1:
      return Task.of(Either.of(albert));

    case 2:
      return Task.of(Either.of(gary));

    case 3:
      return Task.of(Either.of(theresa));

    default:
      return Task.of(left(&apos;not found&apos;));
  }
};

const eitherToTask = namedAs(&apos;eitherToTask&apos;, either(Task.rejected, Task.of));


/* ---------- Chapter 12 ---------- */

const httpGet = function httpGet(route) { return Task.of(`json for ${route}`); };

const routes = new Map({
  &apos;/&apos;: &apos;/&apos;,
  &apos;/about&apos;: &apos;/about&apos;,
});

const validate = function validate(player) {
  return player.name
    ? Either.of(player)
    : left(&apos;must have name&apos;);
};

const readdir = function readdir(dir) {
  return Task.of([&apos;file1&apos;, &apos;file2&apos;, &apos;file3&apos;]);
};

const readfile = curry(function readfile(encoding, file) {
  return Task.of(`content of ${file} (${encoding})`);
});


/* ---------- Exports ---------- */

if (typeof module === &apos;object&apos;) {
  module.exports = {
    // Utils
    withSpyOn,

    // Essential FP helpers
    always,
    compose,
    curry,
    either,
    identity,
    inspect,
    left,
    liftA2,
    liftA3,
    maybe,
    nothing,
    reject,

    // Algebraic Data Structures
    Either,
    IO,
    Identity,
    Left,
    List,
    Map,
    Maybe,
    Right,
    Task,

    // Currified version of &apos;standard&apos; functions
    append,
    add,
    chain,
    concat,
    eq,
    filter,
    flip,
    forEach,
    head,
    intercalate,
    join,
    last,
    map,
    match,
    prop,
    reduce,
    safeHead,
    safeProp,
    sequence,
    sortBy,
    split,
    take,
    toLowerCase,
    toUpperCase,
    traverse,
    unsafePerformIO,

    // Chapter 04
    keepHighest,

    // Chapter 05
    cars,
    average,

    // Chapter 08
    albert,
    gary,
    theresa,
    yi,
    showWelcome,
    checkActive,
    save,
    validateUser,

    // Chapter 09
    getFile,
    pureLog,
    addToMailingList,
    emailBlast,
    validateEmail,

    // Chapter 10
    localStorage,
    getFromCache,
    game,

    // Chapter 11
    findUserById,
    eitherToTask,

    // Chapter 12
    httpGet,
    routes,
    validate,
    readdir,
    readfile,
  };
}</pre>
	

	<div class="buttons">
	    <a href="#" class="button size-2 action-submit">Submit</a>
	    <a href="#" class="button size-2 action-solution">Solution</a>
	</div>
</div>  </p>
<hr>
<p>We now consider the following functions:</p>
<pre><code class="lang-js"><span class="hljs-comment">// validateUser :: (User -&gt; Either String ()) -&gt; User -&gt; Either String User</span>
<span class="hljs-keyword">const</span> validateUser = curry((validate, user) =&gt; validate(user).map(_ =&gt; user));

<span class="hljs-comment">// save :: User -&gt; IO User</span>
<span class="hljs-keyword">const</span> save = user =&gt; <span class="hljs-keyword">new</span> IO(() =&gt; ({ ...user, saved: <span class="hljs-literal">true</span> }));
</code></pre>
<p><div class="exercise">
	<div class="header">Exercise</div>
	<div class="alert alert-success">
	    <b>Correct!</b>
	</div>

	<div class="alert alert-danger error-message">
	    <b>False!</b>
	</div>

	<div class="message">
	  
Write a function `validateName` which checks whether a user has a name longer than 3 characters
or return an error message. Then use `either`, `showWelcome` and `save` to write a `register`
function to signup and welcome a user when the validation is ok.

Remember either&apos;s two arguments must return the same type.


	</div>
	<div class="editor" style="height: 220px">// validateName :: User -&gt; Either String ()
const validateName = undefined;

// register :: User -&gt; IO String
const register = compose(undefined, validateUser(validateName));</div>

	<pre class="hidden code-solution">const validateName = ({ name }) =&gt; (name.length &gt; 3
  ? Either.of(null)
  : left(&apos;Your name need to be &gt; 3&apos;)
);

const saveAndWelcome = compose(map(showWelcome), save);

const register = compose(
  either(IO.of, saveAndWelcome),
  validateUser(validateName),
);</pre>
	<pre class="hidden code-validation">/* globals validateName, register */

const validateGary = validateName(gary);
assert(
  validateGary instanceof Either &amp;&amp; validateGary.isRight,
  &apos;The function `validateName` gives incorrect results.&apos;,
);

const validateYi = validateName(yi);
assert(
  validateYi instanceof Either &amp;&amp; validateYi.isLeft &amp;&amp; typeof validateYi.$value === &apos;string&apos;,
  &apos;The function `validateName` gives incorrect results!&apos;,
);

const registerAlbert = register(albert);
assert(
  registerAlbert instanceof IO,
  &apos;The right outcome to `register` is incorrect; hint: `save` returns an `IO` and you\&apos;ll need `map` to manipulate the inner value!&apos;,
);

const msgAlbert = registerAlbert.unsafePerformIO();
assert(
  typeof msgAlbert === &apos;string&apos;,
  &apos;The right outcome to `register` is incorrect; hint: look carefully at your signatures, `register` should return an `IO(String)` in every scenarios!&apos;,
);

const callees = register.callees || [];

assert(
  callees[callees.length - 1] === &apos;either&apos;,
  &apos;The function `register` seems incorrect; hint: you can use `either` to branch an `Either` to different outcomes!&apos;,
);

assert(
  msgAlbert === showWelcome(albert),
  &apos;The function `register` returns a correct type, but the inner value is incorrect! Did you use `showWelcome`?&apos;,
);

const registerYi = register(yi);
assert(
  registerYi instanceof IO,
  &apos;The left outcome to `register` is incorrect; hint: look carefully at your signatures, `register` should return an `IO` in every scenarios!&apos;,
);

const msgYi = registerYi.unsafePerformIO();
assert(
  typeof msgYi === &apos;string&apos;,
  &apos;The left outcome to `register` is incorrect; hint: look carefully at your signatures, `register` should return an `IO(String)` in every scenarios!&apos;,
);</pre>
	
	<pre class="hidden code-context">// NOTE We keep named function here to leverage this in the `compose` function,
// and later on in the validations scripts.

/* eslint-disable prefer-arrow-callback */


/* ---------- Internals ---------- */

function namedAs(value, fn) {
  Object.defineProperty(fn, &apos;name&apos;, { value });
  return fn;
}


// NOTE This file is loaded by gitbook&apos;s exercises plugin. When it does, there&apos;s an
// `assert` function available in the global scope.

/* eslint-disable no-undef, global-require */
if (typeof assert !== &apos;function&apos; &amp;&amp; typeof require === &apos;function&apos;) {
  global.assert = require(&apos;assert&apos;);
}

assert.arrayEqual = function assertArrayEqual(actual, expected, message = &apos;arrayEqual&apos;) {
  if (actual.length !== expected.length) {
    throw new Error(message);
  }

  for (let i = 0; i &lt; expected.length; i += 1) {
    if (expected[i] !== actual[i]) {
      throw new Error(message);
    }
  }
};
/* eslint-enable no-undef, global-require */


function inspect(x) {
  if (x &amp;&amp; typeof x.inspect === &apos;function&apos;) {
    return x.inspect();
  }

  function inspectFn(f) {
    return f.name ? f.name : f.toString();
  }

  function inspectTerm(t) {
    switch (typeof t) {
      case &apos;string&apos;:
        return `&apos;${t}&apos;`;
      case &apos;object&apos;: {
        const ts = Object.keys(t).map(k =&gt; [k, inspect(t[k])]);
        return `{${ts.map(kv =&gt; kv.join(&apos;: &apos;)).join(&apos;, &apos;)}}`;
      }
      default:
        return String(t);
    }
  }

  function inspectArgs(args) {
    return Array.isArray(args) ? `[${args.map(inspect).join(&apos;, &apos;)}]` : inspectTerm(args);
  }

  return (typeof x === &apos;function&apos;) ? inspectFn(x) : inspectArgs(x);
}


/* eslint-disable no-param-reassign */
function withSpyOn(prop, obj, fn) {
  const orig = obj[prop];
  let called = false;
  obj[prop] = function spy(...args) {
    called = true;
    return orig.call(this, ...args);
  };
  fn();
  obj[prop] = orig;
  return called;
}
/* eslint-enable no-param-reassign */


const typeMismatch = (src, got, fn) =&gt; `Type Mismatch in function &apos;${fn}&apos;

        ${fn} :: ${got}

      instead of

        ${fn} :: ${src}`;


const capitalize = s =&gt; `${s[0].toUpperCase()}${s.substring(1)}`;


const ordinal = (i) =&gt; {
  switch (i) {
    case 1:
      return &apos;1st&apos;;
    case 2:
      return &apos;2nd&apos;;
    case 3:
      return &apos;3rd&apos;;
    default:
      return `${i}th`; // NOTE won&apos;t get any much bigger ...
  }
};

const getType = (x) =&gt; {
  if (x === null) {
    return &apos;Null&apos;;
  }

  if (typeof x === &apos;undefined&apos;) {
    return &apos;()&apos;;
  }

  if (Array.isArray(x)) {
    return `[${x[0] ? getType(x[0]) : &apos;?&apos;}]`;
  }

  if (typeof x.getType === &apos;function&apos;) {
    return x.getType();
  }

  if (x.constructor &amp;&amp; x.constructor.name) {
    return x.constructor.name;
  }

  return capitalize(typeof x);
};


/* ---------- Essential FP Functions ---------- */

// NOTE A slightly pumped up version of `curry` which also keeps track of
// whether a function was called partially or with all its arguments at once.
// This is useful to provide insights during validation of exercises.
function curry(fn) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;function -&gt; ?&apos;, [getType(fn), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;curry&apos;),
  );

  const arity = fn.length;

  return namedAs(fn.name, function $curry(...args) {
    $curry.partially = this &amp;&amp; this.partially;

    if (args.length &lt; arity) {
      return namedAs(fn.name, $curry.bind({ partially: true }, ...args));
    }

    return fn.call(this || { partially: false }, ...args);
  });
}


// NOTE A slightly pumped up version of `compose` which also keeps track of the chain
// of callees. In the end, a function created with `compose` holds a `callees` variable
// with the list of all the callees&apos; names.
// This is useful to provide insights during validation of exercises
function compose(...fns) {
  const n = fns.length;

  return function $compose(...args) {
    $compose.callees = [];

    let $args = args;

    for (let i = n - 1; i &gt;= 0; i -= 1) {
      const fn = fns[i];

      assert(
        typeof fn === &apos;function&apos;,
        `Invalid Composition: ${ordinal(n - i)} element in a composition isn&apos;t a function`,
      );

      $compose.callees.push(fn.name);
      $args = [fn.call(null, ...$args)];
    }

    return $args[0];
  };
}


/* ---------- Algebraic Data Structures ---------- */

class Either {
  static of(x) {
    return new Right(x); // eslint-disable-line no-use-before-define
  }

  constructor(x) {
    this.$value = x;
  }
}


class Left extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return true;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return false;
  }

  ap() {
    return this;
  }

  chain() {
    return this;
  }

  inspect() {
    return `Left(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ${getType(this.$value)} ?)`;
  }

  join() {
    return this;
  }

  map() {
    return this;
  }

  sequence(of) {
    return of(this);
  }

  traverse(of, fn) {
    return of(this);
  }
}


class Right extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return false;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return true;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return fn(this.$value);
  }

  inspect() {
    return `Right(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ? ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Either.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    fn(this.$value).map(Either.of);
  }
}


class Identity {
  static of(x) {
    return new Identity(x);
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `Identity(${inspect(this.$value)})`;
  }

  getType() {
    return `(Identity ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Identity.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return fn(this.$value).map(Identity.of);
  }
}

class IO {
  static of(x) {
    return new IO(() =&gt; x);
  }

  constructor(io) {
    assert(
      typeof io === &apos;function&apos;,
      &apos;invalid `io` operation given to IO constructor. Use `IO.of` if you want to lift a value in a default minimal IO context.&apos;,
    );

    this.unsafePerformIO = io;
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `IO(${inspect(this.unsafePerformIO())})`;
  }

  getType() {
    return `(IO ${getType(this.unsafePerformIO())})`;
  }


  join() {
    return this.unsafePerformIO();
  }

  map(fn) {
    return new IO(compose(fn, this.unsafePerformIO));
  }
}


class Map {
  constructor(x) {
    assert(
      typeof x === &apos;object&apos; &amp;&amp; x !== null,
      &apos;tried to create `Map` with non object-like&apos;,
    );

    this.$value = x;
  }

  inspect() {
    return `Map(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[Object.keys(this.$value)[0]];

    return `(Map String ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  insert(k, v) {
    const singleton = {};
    singleton[k] = v;
    return new Map(Object.assign({}, this.$value, singleton));
  }

  reduce(fn, zero) {
    return this.reduceWithKeys((acc, _, k) =&gt; fn(acc, k), zero);
  }

  reduceWithKeys(fn, zero) {
    return Object.keys(this.$value)
      .reduce((acc, k) =&gt; fn(acc, this.$value[k], k), zero);
  }

  map(fn) {
    return new Map(this.reduceWithKeys((obj, v, k) =&gt; {
      obj[k] = fn(v); // eslint-disable-line no-param-reassign
      return obj;
    }, {}));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.reduceWithKeys(
      (f, a, k) =&gt; fn(a).map(b =&gt; m =&gt; m.insert(k, b)).ap(f),
      of(new Map({})),
    );
  }
}


class List {
  static of(x) {
    return new List([x]);
  }

  constructor(xs) {
    assert(
      Array.isArray(xs),
      &apos;tried to create `List` from non-array&apos;,
    );

    this.$value = xs;
  }

  concat(x) {
    return new List(this.$value.concat(x));
  }

  inspect() {
    return `List(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[0];

    return `(List ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  map(fn) {
    return new List(this.$value.map(fn));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.$value.reduce(
      (f, a) =&gt; fn(a).map(b =&gt; bs =&gt; bs.concat(b)).ap(f),
      of(new List([])),
    );
  }
}


class Maybe {
  static of(x) {
    return new Maybe(x);
  }

  get isNothing() {
    return this.$value === null || this.$value === undefined;
  }

  get isJust() {
    return !this.isNothing;
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return this.isNothing ? this : f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return this.isNothing ? &apos;Nothing&apos; : `Just(${inspect(this.$value)})`;
  }

  getType() {
    return `(Maybe ${this.isJust ? getType(this.$value) : &apos;?&apos;})`;
  }

  join() {
    return this.isNothing ? this : this.$value;
  }

  map(fn) {
    return this.isNothing ? this : Maybe.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.isNothing ? of(this) : fn(this.$value).map(Maybe.of);
  }
}


class Task {
  constructor(fork) {
    assert(
      typeof fork === &apos;function&apos;,
      &apos;invalid `fork` operation given to Task constructor. Use `Task.of` if you want to lift a value in a default minimal Task context.&apos;,
    );

    this.fork = fork;
  }

  static of(x) {
    return new Task((_, resolve) =&gt; resolve(x));
  }

  static rejected(x) {
    return new Task((reject, _) =&gt; reject(x));
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, x =&gt; fn(x).fork(reject, resolve)));
  }

  inspect() { // eslint-disable-line class-methods-use-this
    return &apos;Task(?)&apos;;
  }

  getType() { // eslint-disable-line class-methods-use-this
    return &apos;(Task ? ?)&apos;;
  }

  join() {
    return this.chain(x =&gt; x);
  }

  map(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, compose(resolve, fn)));
  }
}

// In nodejs the existance of a class method named `inspect` will trigger a deprecation warning
// when passing an instance to `console.log`:
// `(node:3845) [DEP0079] DeprecationWarning: Custom inspection function on Objects via .inspect() is deprecated`
// The solution is to alias the existing inspect method with the special inspect symbol exported by node
if (typeof module !== &apos;undefined&apos; &amp;&amp; typeof this !== &apos;undefined&apos; &amp;&amp; this.module !== module) {
  const customInspect = require(&apos;util&apos;).inspect.custom;
  const assignCustomInspect = it =&gt; it.prototype[customInspect] = it.prototype.inspect;
  [Left, Right, Identity, IO, Map, List, Maybe, Task].forEach(assignCustomInspect);
}

const identity = function identity(x) { return x; };

const either = curry(function either(f, g, e) {
  if (e.isLeft) {
    return f(e.$value);
  }

  return g(e.$value);
});

const left = function left(x) { return new Left(x); };

const maybe = curry(function maybe(v, f, m) {
  if (m.isNothing) {
    return v;
  }

  return f(m.$value);
});

const nothing = Maybe.of(null);

const reject = function reject(x) { return Task.rejected(x); };

const chain = curry(function chain(fn, m) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m a&apos;, [getType(fn), getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;chain&apos;),
  );

  return m.chain(fn);
});

const join = function join(m) {
  assert(
    typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; m (m a) -&gt; m a&apos;, [getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;join&apos;),
  );

  return m.join();
};

const map = curry(function map(fn, f) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof f.map === &apos;function&apos;,
    typeMismatch(&apos;Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b&apos;, [getType(fn), getType(f), &apos;f b&apos;].join(&apos; -&gt; &apos;), &apos;map&apos;),
  );

  return f.map(fn);
});

const sequence = curry(function sequence(of, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof x.sequence === &apos;function&apos;,
    typeMismatch(&apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; t (f a) -&gt; f (t a)&apos;, [getType(of), getType(x), &apos;f (t a)&apos;].join(&apos; -&gt; &apos;), &apos;sequence&apos;),
  );

  return x.sequence(of);
});

const traverse = curry(function traverse(of, fn, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof fn === &apos;function&apos; &amp;&amp; typeof x.traverse === &apos;function&apos;,
    typeMismatch(
      &apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)&apos;,
      [getType(of), getType(fn), getType(x), &apos;f (t b)&apos;].join(&apos; -&gt; &apos;),
      &apos;traverse&apos;,
    ),
  );

  return x.traverse(of, fn);
});

const unsafePerformIO = function unsafePerformIO(io) {
  assert(
    io instanceof IO,
    typeMismatch(&apos;IO a&apos;, getType(io), &apos;unsafePerformIO&apos;),
  );

  return io.unsafePerformIO();
};

const liftA2 = curry(function liftA2(fn, a1, a2) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2);
});

const liftA3 = curry(function liftA3(fn, a1, a2, a3) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;
      &amp;&amp; typeof a3.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2).ap(a3);
});

const always = curry(function always(a, b) { return a; });


/* ---------- Pointfree Classic Utilities ---------- */

const append = curry(function append(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return b.concat(a);
});

const add = curry(function add(a, b) {
  assert(
    typeof a === &apos;number&apos; &amp;&amp; typeof b === &apos;number&apos;,
    typeMismatch(&apos;Number -&gt; Number -&gt; Number&apos;, [getType(a), getType(b), &apos;Number&apos;].join(&apos; -&gt; &apos;), &apos;add&apos;),
  );

  return a + b;
});

const concat = curry(function concat(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return a.concat(b);
});

const eq = curry(function eq(a, b) {
  assert(
    getType(a) === getType(b),
    typeMismatch(&apos;a -&gt; a -&gt; Boolean&apos;, [getType(a), getType(b), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), eq),
  );

  return a === b;
});

const filter = curry(function filter(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; Boolean) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;filter&apos;),
  );

  return xs.filter(fn);
});

const flip = curry(function flip(fn, a, b) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;(a -&gt; b) -&gt; (b -&gt; a)&apos;, [getType(fn), &apos;(b -&gt; a)&apos;].join(&apos; -&gt; &apos;), &apos;flip&apos;),
  );

  return fn(b, a);
});

const forEach = curry(function forEach(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; ()) -&gt; [a] -&gt; ()&apos;, [getType(fn), getType(xs), &apos;()&apos;].join(&apos; -&gt; &apos;), &apos;forEach&apos;),
  );

  xs.forEach(fn);
});

const intercalate = curry(function intercalate(str, xs) {
  assert(
    typeof str === &apos;string&apos; &amp;&amp; Array.isArray(xs) &amp;&amp; (xs.length === 0 || typeof xs[0] === &apos;string&apos;),
    typeMismatch(&apos;String -&gt; [String] -&gt; String&apos;, [getType(str), getType(xs), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;intercalate&apos;),
  );

  return xs.join(str);
});

const head = function head(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;head&apos;),
  );

  return xs[0];
};

const last = function last(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;last&apos;),
  );

  return xs[xs.length - 1];
};

const match = curry(function match(re, str) {
  assert(
    re instanceof RegExp &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;RegExp -&gt; String -&gt; Boolean&apos;, [getType(re), getType(str), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), &apos;match&apos;),
  );

  return re.test(str);
});

const prop = curry(function prop(p, obj) {
  assert(
    typeof p === &apos;string&apos; &amp;&amp; typeof obj === &apos;object&apos; &amp;&amp; obj !== null,
    typeMismatch(&apos;String -&gt; Object -&gt; a&apos;, [getType(p), getType(obj), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;prop&apos;),
  );

  return obj[p];
});

const reduce = curry(function reduce(fn, zero, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b&apos;, [getType(fn), getType(zero), getType(xs), &apos;b&apos;].join(&apos; -&gt; &apos;), &apos;reduce&apos;),
  );

  return xs.reduce(
    function $reduceIterator($acc, $x) { return fn($acc, $x); },
    zero,
  );
});

const safeHead = namedAs(&apos;safeHead&apos;, compose(Maybe.of, head));

const safeProp = curry(function safeProp(p, obj) { return Maybe.of(prop(p, obj)); });

const sortBy = curry(function sortBy(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), &apos;[a]&apos;].join(&apos; -&gt; &apos;), &apos;sortBy&apos;),
  );

  return xs.sort((a, b) =&gt; {
    if (fn(a) === fn(b)) {
      return 0;
    }

    return fn(a) &gt; fn(b) ? 1 : -1;
  });
});

const split = curry(function split(s, str) {
  assert(
    typeof s === &apos;string&apos; &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; [String]&apos;, [getType(s), getType(str), &apos;[String]&apos;].join(&apos; -&gt; &apos;), &apos;split&apos;),
  );

  return str.split(s);
});

const take = curry(function take(n, xs) {
  assert(
    typeof n === &apos;number&apos; &amp;&amp; (Array.isArray(xs) || typeof xs === &apos;string&apos;),
    typeMismatch(&apos;Number -&gt; [a] -&gt; [a]&apos;, [getType(n), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;take&apos;),
  );

  return xs.slice(0, n);
});

const toLowerCase = function toLowerCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toLowerCase();
};

const toUpperCase = function toUpperCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toUpperCase();
};


/* ---------- Chapter 4 ---------- */

const keepHighest = function keepHighest(x, y) {
  try {
    keepHighest.calledBy = keepHighest.caller;
  } catch (err) {
    // NOTE node.js runs in strict mode and prohibit the usage of &apos;.caller&apos;
    // There&apos;s a ugly hack to retrieve the caller from stack trace.
    const [, caller] = /at (\S+)/.exec(err.stack.split(&apos;\n&apos;)[2]);

    keepHighest.calledBy = namedAs(caller, () =&gt; {});
  }

  return x &gt;= y ? x : y;
};


/* ---------- Chapter 5 ---------- */

const cars = [{
  name: &apos;Ferrari FF&apos;,
  horsepower: 660,
  dollar_value: 700000,
  in_stock: true,
}, {
  name: &apos;Spyker C12 Zagato&apos;,
  horsepower: 650,
  dollar_value: 648000,
  in_stock: false,
}, {
  name: &apos;Jaguar XKR-S&apos;,
  horsepower: 550,
  dollar_value: 132000,
  in_stock: true,
}, {
  name: &apos;Audi R8&apos;,
  horsepower: 525,
  dollar_value: 114200,
  in_stock: false,
}, {
  name: &apos;Aston Martin One-77&apos;,
  horsepower: 750,
  dollar_value: 1850000,
  in_stock: true,
}, {
  name: &apos;Pagani Huayra&apos;,
  horsepower: 700,
  dollar_value: 1300000,
  in_stock: false,
}];

const average = function average(xs) {
  return xs.reduce(add, 0) / xs.length;
};


/* ---------- Chapter 8 ---------- */

const albert = {
  id: 1,
  active: true,
  name: &apos;Albert&apos;,
  address: {
    street: {
      number: 22,
      name: &apos;Walnut St&apos;,
    },
  },
};

const gary = {
  id: 2,
  active: false,
  name: &apos;Gary&apos;,
  address: {
    street: {
      number: 14,
    },
  },
};

const theresa = {
  id: 3,
  active: true,
  name: &apos;Theresa&apos;,
};

const yi = { id: 4, name: &apos;Yi&apos;, active: true };

const showWelcome = namedAs(&apos;showWelcome&apos;, compose(concat(&apos;Welcome &apos;), prop(&apos;name&apos;)));

const checkActive = function checkActive(user) {
  return user.active
    ? Either.of(user)
    : left(&apos;Your account is not active&apos;);
};

const save = function save(user) {
  return new IO(() =&gt; Object.assign({}, user, { saved: true }));
};

const validateUser = curry(function validateUser(validate, user) {
  return validate(user).map(_ =&gt; user); // eslint-disable-line no-unused-vars
});


/* ---------- Chapter 9 ---------- */

const getFile = IO.of(&apos;/home/mostly-adequate/ch09.md&apos;);

const pureLog = function pureLog(str) { return new IO(() =&gt; { console.log(str); return str; }); };

const addToMailingList = function addToMailingList(email) { return IO.of([email]); };

const emailBlast = function emailBlast(list) { return IO.of(list.join(&apos;,&apos;)); };

const validateEmail = function validateEmail(x) {
  return /\S+@\S+\.\S+/.test(x)
    ? Either.of(x)
    : left(&apos;invalid email&apos;);
};


/* ---------- Chapter 10 ---------- */

const localStorage = { player1: albert, player2: theresa };

const game = curry(function game(p1, p2) { return `${p1.name} vs ${p2.name}`; });

const getFromCache = function getFromCache(x) { return new IO(() =&gt; localStorage[x]); };


/* ---------- Chapter 11 ---------- */

const findUserById = function findUserById(id) {
  switch (id) {
    case 1:
      return Task.of(Either.of(albert));

    case 2:
      return Task.of(Either.of(gary));

    case 3:
      return Task.of(Either.of(theresa));

    default:
      return Task.of(left(&apos;not found&apos;));
  }
};

const eitherToTask = namedAs(&apos;eitherToTask&apos;, either(Task.rejected, Task.of));


/* ---------- Chapter 12 ---------- */

const httpGet = function httpGet(route) { return Task.of(`json for ${route}`); };

const routes = new Map({
  &apos;/&apos;: &apos;/&apos;,
  &apos;/about&apos;: &apos;/about&apos;,
});

const validate = function validate(player) {
  return player.name
    ? Either.of(player)
    : left(&apos;must have name&apos;);
};

const readdir = function readdir(dir) {
  return Task.of([&apos;file1&apos;, &apos;file2&apos;, &apos;file3&apos;]);
};

const readfile = curry(function readfile(encoding, file) {
  return Task.of(`content of ${file} (${encoding})`);
});


/* ---------- Exports ---------- */

if (typeof module === &apos;object&apos;) {
  module.exports = {
    // Utils
    withSpyOn,

    // Essential FP helpers
    always,
    compose,
    curry,
    either,
    identity,
    inspect,
    left,
    liftA2,
    liftA3,
    maybe,
    nothing,
    reject,

    // Algebraic Data Structures
    Either,
    IO,
    Identity,
    Left,
    List,
    Map,
    Maybe,
    Right,
    Task,

    // Currified version of &apos;standard&apos; functions
    append,
    add,
    chain,
    concat,
    eq,
    filter,
    flip,
    forEach,
    head,
    intercalate,
    join,
    last,
    map,
    match,
    prop,
    reduce,
    safeHead,
    safeProp,
    sequence,
    sortBy,
    split,
    take,
    toLowerCase,
    toUpperCase,
    traverse,
    unsafePerformIO,

    // Chapter 04
    keepHighest,

    // Chapter 05
    cars,
    average,

    // Chapter 08
    albert,
    gary,
    theresa,
    yi,
    showWelcome,
    checkActive,
    save,
    validateUser,

    // Chapter 09
    getFile,
    pureLog,
    addToMailingList,
    emailBlast,
    validateEmail,

    // Chapter 10
    localStorage,
    getFromCache,
    game,

    // Chapter 11
    findUserById,
    eitherToTask,

    // Chapter 12
    httpGet,
    routes,
    validate,
    readdir,
    readfile,
  };
}</pre>
	

	<div class="buttons">
	    <a href="#" class="button size-2 action-submit">Submit</a>
	    <a href="#" class="button size-2 action-solution">Solution</a>
	</div>
</div>  </p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="ch07-kr.html#요약" class="navigation navigation-prev " aria-label="Previous page: 요약">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ch08.html#the-mighty-container" class="navigation navigation-next " aria-label="Next page: The Mighty Container">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Chapter 08: Tupperware","level":"1.9","depth":1,"next":{"title":"The Mighty Container","level":"1.9.1","depth":2,"anchor":"#the-mighty-container","path":"ch08.md","ref":"ch08.md#the-mighty-container","articles":[]},"previous":{"title":"요약","level":"1.8.6","depth":2,"anchor":"#요약","path":"ch07-kr.md","ref":"ch07-kr.md#요약","articles":[]},"dir":"ltr"},"config":{"plugins":["exercises@git+https://github.com/MostlyAdequate/plugin-exercises.git","include-codeblock@3.1.2"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"exercises":{},"include-codeblock":{"check":false,"edit":false,"lang":"","fixlang":false,"template":"default","theme":"chrome","unindent":false},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"cover":"images/cover.png","title":"Professor Frisby's Mostly Adequate Guide to Functional Programming","gitbook":"3.2.2"},"file":{"path":"ch08.md","mtime":"2023-03-16T13:34:28.228Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2023-03-16T13:35:26.336Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook-plugin-exercises/jsrepl/jsrepl.js" id="jsrepl-script"></script>
    
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-exercises/ace/ace.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-exercises/ace/theme-tomorrow.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-exercises/ace/mode-javascript.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-exercises/exercises.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    


    </body>
</html>

