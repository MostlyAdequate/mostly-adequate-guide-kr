
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Chapter 11: Transform Again, Naturally · Professor Frisby's Mostly Adequate Guide to Functional Programming</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-exercises/exercises.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ch11.html" />
    
    
    <link rel="prev" href="ch10.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="ch01-kr.html">
            
                <a href="ch01-kr.html">
            
                    
                    01 장: 우리는 무엇을 하고 있나?
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="ch01-kr.html">
            
                <a href="ch01-kr.html#소개">
            
                    
                    소개
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="ch01-kr.html">
            
                <a href="ch01-kr.html#짧은-만남">
            
                    
                    짧은 만남
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="ch02-kr.html">
            
                <a href="ch02-kr.html">
            
                    
                    02 장: 일급 함수
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="ch02-kr.html">
            
                <a href="ch02-kr.html#복습-시간">
            
                    
                    복습 시간
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="ch02-kr.html">
            
                <a href="ch02-kr.html#일급-함수의-장점">
            
                    
                    일급 함수의 장점
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="ch03-kr.html">
            
                <a href="ch03-kr.html">
            
                    
                    03 장: 순수 함수와 순수한 기쁨을
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="ch03-kr.html">
            
                <a href="ch03-kr.html#한번-더-순수함에-대하여">
            
                    
                    한번 더 순수함에 대하여
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="ch03-kr.html">
            
                <a href="ch03-kr.html#부수효과는-를-포함할-수-있어요">
            
                    
                    부수효과는 ...를 포함할 수 있어요
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="ch03-kr.html">
            
                <a href="ch03-kr.html#중학교-2학년-수학">
            
                    
                    중학교 2학년 수학
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="ch03-kr.html">
            
                <a href="ch03-kr.html#순수성의-예">
            
                    
                    순수성의 예
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="ch03-kr.html">
            
                <a href="ch03-kr.html#요약">
            
                    
                    요약
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="ch04-kr.html">
            
                <a href="ch04-kr.html">
            
                    
                    04 장: 커링
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="ch04-kr.html">
            
                <a href="ch04-kr.html#cant-live-if-livin-is-without-you">
            
                    
                    Can't Live If Livin' Is without You
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="ch04-kr.html">
            
                <a href="ch04-kr.html#말장난-조금-더--특별한-소스">
            
                    
                    말장난 조금 더 / 특별한 소스
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="ch04.md-kr">
            
                <span>
            
                    
                    요약
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="ch04.md-kr">
            
                <span>
            
                    
                    연습문제
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="ch05.html">
            
                <a href="ch05.html">
            
                    
                    Chapter 05: Coding by Composing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="ch05.html">
            
                <a href="ch05.html#functional-husbandry">
            
                    
                    Functional Husbandry
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="ch05.html">
            
                <a href="ch05.html#pointfree">
            
                    
                    Pointfree
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="ch05.html">
            
                <a href="ch05.html#debugging">
            
                    
                    Debugging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="ch05.html">
            
                <a href="ch05.html#category-theory">
            
                    
                    Category Theory
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="ch05.html">
            
                <a href="ch05.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="ch05.html">
            
                <a href="ch05.html#exercises">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="ch06.html">
            
                <a href="ch06.html">
            
                    
                    Chapter 06: Example Application
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="ch06.html">
            
                <a href="ch06.html#declarative-coding">
            
                    
                    Declarative Coding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="ch06.html">
            
                <a href="ch06.html#a-flickr-of-functional-programming">
            
                    
                    A Flickr of Functional Programming
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="ch06.html">
            
                <a href="ch06.html#a-principled-refactor">
            
                    
                    A Principled Refactor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="ch06.html">
            
                <a href="ch06.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html">
            
                    
                    07 장: 힌들리-밀너와 나
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html#당신은-무슨-타입인가요">
            
                    
                    당신은 무슨 타입인가요?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html#비밀-이야기">
            
                    
                    비밀 이야기
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html#가능성을-높이기">
            
                    
                    가능성을 높이기
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html#공짜로-정리-얻기">
            
                    
                    공짜로 정리 얻기
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html#제약">
            
                    
                    제약
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.6" data-path="ch07-kr.html">
            
                <a href="ch07-kr.html#요약">
            
                    
                    요약
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="ch08.html">
            
                <a href="ch08.html">
            
                    
                    Chapter 08: Tupperware
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="ch08.html">
            
                <a href="ch08.html#the-mighty-container">
            
                    
                    The Mighty Container
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="ch08.html">
            
                <a href="ch08.html#my-first-functor">
            
                    
                    My First Functor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="ch08.html">
            
                <a href="ch08.html#schrödingers-maybe">
            
                    
                    Schrödinger's Maybe
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="ch08.html">
            
                <a href="ch08.html#use-cases">
            
                    
                    Use Cases
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="ch08.html">
            
                <a href="ch08.html#releasing-the-value">
            
                    
                    Releasing the Value
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="ch08.html">
            
                <a href="ch08.html#pure-error-handling">
            
                    
                    Pure Error Handling
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="ch08.html">
            
                <a href="ch08.html#old-mcdonald-had-effects">
            
                    
                    Old McDonald Had Effects...
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.8" data-path="ch08.html">
            
                <a href="ch08.html#asynchronous-tasks">
            
                    
                    Asynchronous Tasks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.9" data-path="ch08.html">
            
                <a href="ch08.html#a-spot-of-theory">
            
                    
                    A Spot of Theory
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.10" data-path="ch08.html">
            
                <a href="ch08.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.11" data-path="ch08.html">
            
                <a href="ch08.html#exercises">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="ch09.html">
            
                <a href="ch09.html">
            
                    
                    Chapter 09: Monadic Onions
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="ch09.html">
            
                <a href="ch09.html#pointy-functor-factory">
            
                    
                    Pointy Functor Factory
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="ch09.html">
            
                <a href="ch09.html#mixing-metaphors">
            
                    
                    Mixing Metaphors
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="ch09.html">
            
                <a href="ch09.html#my-chain-hits-my-chest">
            
                    
                    My Chain Hits My Chest
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="ch09.html">
            
                <a href="ch09.html#power-trip">
            
                    
                    Power Trip
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="ch09.html">
            
                <a href="ch09.html#theory">
            
                    
                    Theory
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="ch09.html">
            
                <a href="ch09.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="ch09.html">
            
                <a href="ch09.html#exercises">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="ch10.html">
            
                <a href="ch10.html">
            
                    
                    Chapter 10: Applicative Functors
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="ch10.html">
            
                <a href="ch10.html#applying-applicatives">
            
                    
                    Applying Applicatives
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="ch10.html">
            
                <a href="ch10.html#ships-in-bottles">
            
                    
                    Ships in Bottles
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="ch10.html">
            
                <a href="ch10.html#coordination-motivation">
            
                    
                    Coordination Motivation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.4" data-path="ch10.html">
            
                <a href="ch10.html#bro-do-you-even-lift">
            
                    
                    Bro, Do You Even Lift?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.5" data-path="ch10.html">
            
                <a href="ch10.html#operators">
            
                    
                    Operators
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.6" data-path="ch10.html">
            
                <a href="ch10.html#free-can-openers">
            
                    
                    Free Can Openers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.7" data-path="ch10.html">
            
                <a href="ch10.html#laws">
            
                    
                    Laws
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.8" data-path="ch10.html">
            
                <a href="ch10.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.9" data-path="ch10.html">
            
                <a href="ch10.html#exercises">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter active" data-level="1.12" data-path="ch11.html">
            
                <a href="ch11.html">
            
                    
                    Chapter 11: Transform Again, Naturally
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="ch11.html">
            
                <a href="ch11.html#curse-this-nest">
            
                    
                    Curse This Nest
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="ch11.html">
            
                <a href="ch11.html#a-situational-comedy">
            
                    
                    A Situational Comedy
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="ch11.html">
            
                <a href="ch11.html#all-natural">
            
                    
                    All Natural
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.4" data-path="ch11.html">
            
                <a href="ch11.html#principled-type-conversions">
            
                    
                    Principled Type Conversions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.5" data-path="ch11.html">
            
                <a href="ch11.html#feature-envy">
            
                    
                    Feature Envy
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.6" data-path="ch11.html">
            
                <a href="ch11.html#isomorphic-javascript">
            
                    
                    Isomorphic JavaScript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.7" data-path="ch11.html">
            
                <a href="ch11.html#a-broader-definition">
            
                    
                    A Broader Definition
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.8" data-path="ch11.html">
            
                <a href="ch11.html#one-nesting-solution">
            
                    
                    One Nesting Solution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.9" data-path="ch11.html">
            
                <a href="ch11.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.10" data-path="ch11.html">
            
                <a href="ch11.html#exercises">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="ch12.html">
            
                <a href="ch12.html">
            
                    
                    Chapter 12: Traversing the Stone
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.13.1" data-path="ch12.html">
            
                <a href="ch12.html#types-n-types">
            
                    
                    Types n' Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.2" data-path="ch12.html">
            
                <a href="ch12.html#type-feng-shui">
            
                    
                    Type Feng Shui
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.3" data-path="ch12.html">
            
                <a href="ch12.html#effect-assortment">
            
                    
                    Effect Assortment
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.4" data-path="ch12.html">
            
                <a href="ch12.html#waltz-of-the-types">
            
                    
                    Waltz of the Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.5" data-path="ch12.html">
            
                <a href="ch12.html#no-law-and-order">
            
                    
                    No Law and Order
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.6" data-path="ch12.html">
            
                <a href="ch12.html#in-summary">
            
                    
                    In Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13.7" data-path="ch12.html">
            
                <a href="ch12.html#exercises">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="appendix_a.html">
            
                <a href="appendix_a.html">
            
                    
                    Appendix A: Essential Functions Support
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" data-path="appendix_a.html">
            
                <a href="appendix_a.html#always">
            
                    
                    always
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2" data-path="appendix_a.html">
            
                <a href="appendix_a.html#compose">
            
                    
                    compose
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.3" data-path="appendix_a.html">
            
                <a href="appendix_a.html#curry">
            
                    
                    curry
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.4" data-path="appendix_a.html">
            
                <a href="appendix_a.html#either">
            
                    
                    either
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.5" data-path="appendix_a.html">
            
                <a href="appendix_a.html#identity">
            
                    
                    identity
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.6" data-path="appendix_a.html">
            
                <a href="appendix_a.html#inspect">
            
                    
                    inspect
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.7" data-path="appendix_a.html">
            
                <a href="appendix_a.html#left">
            
                    
                    left
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.8" data-path="appendix_a.html">
            
                <a href="appendix_a.html#lifta">
            
                    
                    liftA*
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.9" data-path="appendix_a.html">
            
                <a href="appendix_a.html#maybe">
            
                    
                    maybe
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.10" data-path="appendix_a.html">
            
                <a href="appendix_a.html#nothing">
            
                    
                    nothing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.11" data-path="appendix_a.html">
            
                <a href="appendix_a.html#reject">
            
                    
                    reject
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="appendix_b.html">
            
                <a href="appendix_b.html">
            
                    
                    Appendix B: Algebraic Structures Support
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="appendix_b.html">
            
                <a href="appendix_b.html#compose">
            
                    
                    Compose
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.2" data-path="appendix_b.html">
            
                <a href="appendix_b.html#either">
            
                    
                    Either
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.3" data-path="appendix_b.html">
            
                <a href="appendix_b.html#identity">
            
                    
                    Identity
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.4" data-path="appendix_b.html">
            
                <a href="appendix_b.html#io">
            
                    
                    IO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.5" data-path="appendix_b.html">
            
                <a href="appendix_b.html#list">
            
                    
                    List
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.6" data-path="appendix_b.html">
            
                <a href="appendix_b.html#map">
            
                    
                    Map
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.7" data-path="appendix_b.html">
            
                <a href="appendix_b.html#maybe">
            
                    
                    Maybe
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15.8" data-path="appendix_b.html">
            
                <a href="appendix_b.html#task">
            
                    
                    Task
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="appendix_c.html">
            
                <a href="appendix_c.html">
            
                    
                    Appendix C: Pointfree Utilities
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="appendix_c.html">
            
                <a href="appendix_c.html#add">
            
                    
                    add
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.2" data-path="appendix_c.html">
            
                <a href="appendix_c.html#append">
            
                    
                    append
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.3" data-path="appendix_c.html">
            
                <a href="appendix_c.html#chain">
            
                    
                    chain
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.4" data-path="appendix_c.html">
            
                <a href="appendix_c.html#concat">
            
                    
                    concat
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.5" data-path="appendix_c.html">
            
                <a href="appendix_c.html#eq">
            
                    
                    eq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.6" data-path="appendix_c.html">
            
                <a href="appendix_c.html#filter">
            
                    
                    filter
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.7" data-path="appendix_c.html">
            
                <a href="appendix_c.html#flip">
            
                    
                    flip
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.8" data-path="appendix_c.html">
            
                <a href="appendix_c.html#foreach">
            
                    
                    forEach
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.9" data-path="appendix_c.html">
            
                <a href="appendix_c.html#head">
            
                    
                    head
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.10" data-path="appendix_c.html">
            
                <a href="appendix_c.html#intercalate">
            
                    
                    intercalate
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.11" data-path="appendix_c.html">
            
                <a href="appendix_c.html#join">
            
                    
                    join
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.12" data-path="appendix_c.html">
            
                <a href="appendix_c.html#last">
            
                    
                    last
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.13" data-path="appendix_c.html">
            
                <a href="appendix_c.html#map">
            
                    
                    map
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.14" data-path="appendix_c.html">
            
                <a href="appendix_c.html#match">
            
                    
                    match
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.15" data-path="appendix_c.html">
            
                <a href="appendix_c.html#prop">
            
                    
                    prop
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.16" data-path="appendix_c.html">
            
                <a href="appendix_c.html#reduce">
            
                    
                    reduce
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.17" data-path="appendix_c.html">
            
                <a href="appendix_c.html#replace">
            
                    
                    replace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.18" data-path="appendix_c.html">
            
                <a href="appendix_c.html#safehead">
            
                    
                    safeHead
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.19" data-path="appendix_c.html">
            
                <a href="appendix_c.html#safelast">
            
                    
                    safeLast
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.20" data-path="appendix_c.html">
            
                <a href="appendix_c.html#safeprop">
            
                    
                    safeProp
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.21" data-path="appendix_c.html">
            
                <a href="appendix_c.html#sequence">
            
                    
                    sequence
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.22" data-path="appendix_c.html">
            
                <a href="appendix_c.html#sortby">
            
                    
                    sortBy
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.23" data-path="appendix_c.html">
            
                <a href="appendix_c.html#split">
            
                    
                    split
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.24" data-path="appendix_c.html">
            
                <a href="appendix_c.html#take">
            
                    
                    take
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.25" data-path="appendix_c.html">
            
                <a href="appendix_c.html#tolowercase">
            
                    
                    toLowerCase
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.26" data-path="appendix_c.html">
            
                <a href="appendix_c.html#tostring">
            
                    
                    toString
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.27" data-path="appendix_c.html">
            
                <a href="appendix_c.html#touppercase">
            
                    
                    toUpperCase
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.28" data-path="appendix_c.html">
            
                <a href="appendix_c.html#traverse">
            
                    
                    traverse
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.29" data-path="appendix_c.html">
            
                <a href="appendix_c.html#unsafeperformio">
            
                    
                    unsafePerformIO
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Chapter 11: Transform Again, Naturally</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="chapter-11-transform-again-naturally">Chapter 11: Transform Again, Naturally</h1>
<p>We are about to discuss <em>natural transformations</em> in the context of practical utility in every day code. It just so happens they are a pillar of category theory and absolutely indispensable when applying mathematics to reason about and refactor our code. As such, I believe it is my duty to inform you about the lamentable injustice you are about to witness undoubtedly due to my limited scope. Let&apos;s begin.</p>
<h2 id="curse-this-nest">Curse This Nest</h2>
<p>I&apos;d like to address the issue of nesting. Not the instinctive urge felt by soon to be parents wherein they tidy and rearrange with obsessive compulsion, but the...well actually, come to think of it, that isn&apos;t far from the mark as we&apos;ll see in the coming chapters... In any case, what I mean by <em>nesting</em> is to have two or more different types all huddled together around a value, cradling it like a newborn, as it were.</p>
<pre><code class="lang-js">Right(Maybe(<span class="hljs-string">&apos;b&apos;</span>));

IO(Task(IO(<span class="hljs-number">1000</span>)));

[Identity(<span class="hljs-string">&apos;bee thousand&apos;</span>)];
</code></pre>
<p>Until now, we&apos;ve managed to evade this common scenario with carefully crafted examples, but in practice, as one codes, types tend to tangle themselves up like earbuds in an exorcism. If we don&apos;t meticulously keep our types organized as we go along, our code will read hairier than a beatnik in a cat caf&#xE9;.</p>
<h2 id="a-situational-comedy">A Situational Comedy</h2>
<pre><code class="lang-js"><span class="hljs-comment">// getValue :: Selector -&gt; Task Error (Maybe String)</span>
<span class="hljs-comment">// postComment :: String -&gt; Task Error Comment</span>
<span class="hljs-comment">// validate :: String -&gt; Either ValidationError String</span>

<span class="hljs-comment">// saveComment :: () -&gt; Task Error (Maybe (Either ValidationError (Task Error Comment)))</span>
<span class="hljs-keyword">const</span> saveComment = compose(
  map(map(map(postComment))),
  map(map(validate)),
  getValue(<span class="hljs-string">&apos;#comment&apos;</span>),
);
</code></pre>
<p>The gang is all here, much to our type signature&apos;s dismay. Allow me to briefly explain the code. We start by getting the user input with <code>getValue(&apos;#comment&apos;)</code> which is an action which retrieves text on an element. Now, it might error finding the element or the value string may not exist so it returns <code>Task Error (Maybe String)</code>. After that, we must <code>map</code> over both the <code>Task</code> and the <code>Maybe</code> to pass our text to <code>validate</code>, which in turn, gives us back <code>Either</code> a <code>ValidationError</code> or our <code>String</code>. Then onto mapping for days to send the <code>String</code> in our current <code>Task Error (Maybe (Either ValidationError String))</code> into <code>postComment</code> which returns our resulting <code>Task</code>.</p>
<p>What a frightful mess. A collage of abstract types, amateur type expressionism, polymorphic Pollock, monolithic Mondrian. There are many solutions to this common issue. We can compose the types into one monstrous container, sort and <code>join</code> a few, homogenize them, deconstruct them, and so on. In this chapter, we&apos;ll focus on homogenizing them via <em>natural transformations</em>.</p>
<h2 id="all-natural">All Natural</h2>
<p>A <em>Natural Transformation</em> is a &quot;morphism between functors&quot;, that is, a function which operates on the containers themselves. Typewise, it is a function <code>(Functor f, Functor g) =&gt; f a -&gt; g a</code>. What makes it special is that we cannot, for any reason, peek at the contents of our functor. Think of it as an exchange of highly classified information - the two parties oblivious to what&apos;s in the sealed manila envelope stamped &quot;top secret&quot;. This is a structural operation. A functorial costume change. Formally, a <em>natural transformation</em> is any function for which the following holds:</p>
<p><img width="600" src="images/natural_transformation.png" alt="natural transformation diagram"></p>
<p>or in code:</p>
<pre><code class="lang-js"><span class="hljs-comment">// nt :: (Functor f, Functor g) =&gt; f a -&gt; g a</span>
compose(map(f), nt) === compose(nt, map(f));
</code></pre>
<p>Both the diagram and the code say the same thing: We can run our natural transformation then <code>map</code> or <code>map</code> then run our natural transformation and get the same result. Incidentally, that follows from a <a href="ch07.md#free-as-in-theorem">free theorem</a> though natural transformations (and functors) are not limited to functions on types.</p>
<h2 id="principled-type-conversions">Principled Type Conversions</h2>
<p>As programmers we are familiar with type conversions. We transform types like <code>Strings</code> into <code>Booleans</code> and <code>Integers</code> into <code>Floats</code> (though JavaScript only has <code>Numbers</code>). The difference here is simply that we&apos;re working with algebraic containers and we have some theory at our disposal.</p>
<p>Let&apos;s look at some of these as examples:</p>
<pre><code class="lang-js"><span class="hljs-comment">// idToMaybe :: Identity a -&gt; Maybe a</span>
<span class="hljs-keyword">const</span> idToMaybe = x =&gt; Maybe.of(x.$value);

<span class="hljs-comment">// idToIO :: Identity a -&gt; IO a</span>
<span class="hljs-keyword">const</span> idToIO = x =&gt; IO.of(x.$value);

<span class="hljs-comment">// eitherToTask :: Either a b -&gt; Task a b</span>
<span class="hljs-keyword">const</span> eitherToTask = either(Task.rejected, Task.of);

<span class="hljs-comment">// ioToTask :: IO a -&gt; Task () a</span>
<span class="hljs-keyword">const</span> ioToTask = x =&gt; <span class="hljs-keyword">new</span> Task((reject, resolve) =&gt; resolve(x.unsafePerform()));

<span class="hljs-comment">// maybeToTask :: Maybe a -&gt; Task () a</span>
<span class="hljs-keyword">const</span> maybeToTask = x =&gt; (x.isNothing ? Task.rejected() : Task.of(x.$value));

<span class="hljs-comment">// arrayToMaybe :: [a] -&gt; Maybe a</span>
<span class="hljs-keyword">const</span> arrayToMaybe = x =&gt; Maybe.of(x[<span class="hljs-number">0</span>]);
</code></pre>
<p>See the idea? We&apos;re just changing one functor to another. We are permitted to lose information along the way so long as the value we&apos;ll <code>map</code> doesn&apos;t get lost in the shape shift shuffle. That is the whole point: <code>map</code> must carry on, according to our definition, even after the transformation.</p>
<p>One way to look at it is that we are transforming our effects. In that light, we can view <code>ioToTask</code> as converting synchronous to asynchronous or <code>arrayToMaybe</code> from nondeterminism to possible failure. Note that we cannot convert asynchronous to synchronous in JavaScript so we cannot write <code>taskToIO</code> - that would be a supernatural transformation.</p>
<h2 id="feature-envy">Feature Envy</h2>
<p>Suppose we&apos;d like to use some features from another type like <code>sortBy</code> on a <code>List</code>. <em>Natural transformations</em> provide a nice way to convert to the target type knowing our <code>map</code> will be sound.</p>
<pre><code class="lang-js"><span class="hljs-comment">// arrayToList :: [a] -&gt; List a</span>
<span class="hljs-keyword">const</span> arrayToList = List.of;

<span class="hljs-keyword">const</span> doListyThings = compose(sortBy(h), filter(g), arrayToList, map(f));
<span class="hljs-keyword">const</span> doListyThings_ = compose(sortBy(h), filter(g), map(f), arrayToList); <span class="hljs-comment">// law applied</span>
</code></pre>
<p>A wiggle of our nose, three taps of our wand, drop in <code>arrayToList</code>, and voil&#xE0;! Our <code>[a]</code> is a <code>List a</code> and we can <code>sortBy</code> if we please.</p>
<p>Also, it becomes easier to optimize / fuse operations by moving <code>map(f)</code> to the left of <em>natural transformation</em> as shown in <code>doListyThings_</code>.</p>
<h2 id="isomorphic-javascript">Isomorphic JavaScript</h2>
<p>When we can completely go back and forth without losing any information, that is considered an <em>isomorphism</em>. That&apos;s just a fancy word for &quot;holds the same data&quot;. We say that two types are <em>isomorphic</em> if we can provide the &quot;to&quot; and &quot;from&quot; <em>natural transformations</em> as proof:</p>
<pre><code class="lang-js"><span class="hljs-comment">// promiseToTask :: Promise a b -&gt; Task a b</span>
<span class="hljs-keyword">const</span> promiseToTask = x =&gt; <span class="hljs-keyword">new</span> Task((reject, resolve) =&gt; x.then(resolve).catch(reject));

<span class="hljs-comment">// taskToPromise :: Task a b -&gt; Promise a b</span>
<span class="hljs-keyword">const</span> taskToPromise = x =&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; x.fork(reject, resolve));

<span class="hljs-keyword">const</span> x = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&apos;ring&apos;</span>);
taskToPromise(promiseToTask(x)) === x;

<span class="hljs-keyword">const</span> y = Task.of(<span class="hljs-string">&apos;rabbit&apos;</span>);
promiseToTask(taskToPromise(y)) === y;
</code></pre>
<p>Q.E.D. <code>Promise</code> and <code>Task</code> are <em>isomorphic</em>. We can also write a <code>listToArray</code> to complement our <code>arrayToList</code> and show that they are too. As a counter example, <code>arrayToMaybe</code> is not an <em>isomorphism</em> since it loses information:</p>
<pre><code class="lang-js"><span class="hljs-comment">// maybeToArray :: Maybe a -&gt; [a]</span>
<span class="hljs-keyword">const</span> maybeToArray = x =&gt; (x.isNothing ? [] : [x.$value]);

<span class="hljs-comment">// arrayToMaybe :: [a] -&gt; Maybe a</span>
<span class="hljs-keyword">const</span> arrayToMaybe = x =&gt; Maybe.of(x[<span class="hljs-number">0</span>]);

<span class="hljs-keyword">const</span> x = [<span class="hljs-string">&apos;elvis costello&apos;</span>, <span class="hljs-string">&apos;the attractions&apos;</span>];

<span class="hljs-comment">// not isomorphic</span>
maybeToArray(arrayToMaybe(x)); <span class="hljs-comment">// [&apos;elvis costello&apos;]</span>

<span class="hljs-comment">// but is a natural transformation</span>
compose(arrayToMaybe, map(replace(<span class="hljs-string">&apos;elvis&apos;</span>, <span class="hljs-string">&apos;lou&apos;</span>)))(x); <span class="hljs-comment">// Just(&apos;lou costello&apos;)</span>
<span class="hljs-comment">// ==</span>
compose(map(replace(<span class="hljs-string">&apos;elvis&apos;</span>, <span class="hljs-string">&apos;lou&apos;</span>), arrayToMaybe))(x); <span class="hljs-comment">// Just(&apos;lou costello&apos;)</span>
</code></pre>
<p>They are indeed <em>natural transformations</em>, however, since <code>map</code> on either side yields the same result. I mention <em>isomorphisms</em> here, mid-chapter while we&apos;re on the subject, but don&apos;t let that fool you, they are an enormously powerful and pervasive concept. Anyways, let&apos;s move on.</p>
<h2 id="a-broader-definition">A Broader Definition</h2>
<p>These structural functions aren&apos;t limited to type conversions by any means.</p>
<p>Here are a few different ones:</p>
<pre><code class="lang-hs"><span class="hljs-title">reverse</span> :: [a] -&gt; [a]

<span class="hljs-title">join</span> :: (<span class="hljs-type">Monad</span> m) =&gt; m (m a) -&gt; m a

<span class="hljs-title">head</span> :: [a] -&gt; a

<span class="hljs-title">of</span> :: a -&gt; f a
</code></pre>
<p>The natural transformation laws hold for these functions too. One thing that might trip you up is that <code>head :: [a] -&gt; a</code> can be viewed as <code>head :: [a] -&gt; Identity a</code>. We are free to insert <code>Identity</code> wherever we please whilst proving laws since we can, in turn, prove that <code>a</code> is isomorphic to <code>Identity a</code> (see, I told you <em>isomorphisms</em> were pervasive).</p>
<h2 id="one-nesting-solution">One Nesting Solution</h2>
<p>Back to our comedic type signature. We can sprinkle in some <em>natural transformations</em> throughout the calling code to coerce each varying type so they are uniform and, therefore, <code>join</code>able.</p>
<pre><code class="lang-js"><span class="hljs-comment">// getValue :: Selector -&gt; Task Error (Maybe String)</span>
<span class="hljs-comment">// postComment :: String -&gt; Task Error Comment</span>
<span class="hljs-comment">// validate :: String -&gt; Either ValidationError String</span>

<span class="hljs-comment">// saveComment :: () -&gt; Task Error Comment</span>
<span class="hljs-keyword">const</span> saveComment = compose(
  chain(postComment),
  chain(eitherToTask),
  map(validate),
  chain(maybeToTask),
  getValue(<span class="hljs-string">&apos;#comment&apos;</span>),
);
</code></pre>
<p>So what do we have here? We&apos;ve simply added <code>chain(maybeToTask)</code> and <code>chain(eitherToTask)</code>. Both have the same effect; they naturally transform the functor our <code>Task</code> is holding into another <code>Task</code> then <code>join</code> the two. Like pigeon spikes on a window ledge, we avoid nesting right at the source. As they say in the city of light, &quot;Mieux vaut pr&#xE9;venir que gu&#xE9;rir&quot; - an ounce of prevention is worth a pound of cure.</p>
<h2 id="in-summary">In Summary</h2>
<p><em>Natural transformations</em> are functions on our functors themselves. They are an extremely important concept in category theory and will start to appear everywhere once more abstractions are adopted, but for now, we&apos;ve scoped them to a few concrete applications. As we saw, we can achieve different effects by converting types with the guarantee that our composition will hold. They can also help us with nested types, although they have the general effect of homogenizing our functors to the lowest common denominator, which in practice, is the functor with the most volatile effects (<code>Task</code> in most cases).</p>
<p>This continual and tedious sorting of types is the price we pay for having materialized them - summoned them from the ether. Of course, implicit effects are much more insidious and so here we are fighting the good fight. We&apos;ll need a few more tools in our tackle before we can reel in the larger type amalgamations. Next up, we&apos;ll look at reordering our types with <em>Traversable</em>.</p>
<p><a href="ch12.html">Chapter 12: Traversing the Stone</a></p>
<h2 id="exercises">Exercises</h2>
<p><div class="exercise">
	<div class="header">Exercise</div>
	<div class="alert alert-success">
	    <b>Correct!</b>
	</div>

	<div class="alert alert-danger error-message">
	    <b>False!</b>
	</div>

	<div class="message">
	  
Write a natural transformation that converts `Either b a` to `Maybe a`
  

	</div>
	<div class="editor" style="height: 20px">// eitherToMaybe :: Either b a -&gt; Maybe a
const eitherToMaybe = undefined;</div>

	<pre class="hidden code-solution">const eitherToMaybe = either(always(nothing), Maybe.of);</pre>
	<pre class="hidden code-validation">/* globals eitherToMaybe */

const just = eitherToMaybe(Either.of(&apos;one eyed willy&apos;));
const noth = eitherToMaybe(left(&apos;some error&apos;));

assert(
  just instanceof Maybe &amp;&amp; just.isJust &amp;&amp; just.$value === &apos;one eyed willy&apos;,
  &apos;The function maps the `Right()` side incorrectly; hint: `Right(14)` should be mapped to `Just(14)`&apos;,
);

assert(
  noth instanceof Maybe &amp;&amp; noth.isNothing,
  &apos;The function maps the `Left()` side incorrectly; hint: `Left(\&apos;error\&apos;)` should be mapped to `Nothing`&apos;,
);</pre>
	
	<pre class="hidden code-context">// NOTE We keep named function here to leverage this in the `compose` function,
// and later on in the validations scripts.

/* eslint-disable prefer-arrow-callback */


/* ---------- Internals ---------- */

function namedAs(value, fn) {
  Object.defineProperty(fn, &apos;name&apos;, { value });
  return fn;
}


// NOTE This file is loaded by gitbook&apos;s exercises plugin. When it does, there&apos;s an
// `assert` function available in the global scope.

/* eslint-disable no-undef, global-require */
if (typeof assert !== &apos;function&apos; &amp;&amp; typeof require === &apos;function&apos;) {
  global.assert = require(&apos;assert&apos;);
}

assert.arrayEqual = function assertArrayEqual(actual, expected, message = &apos;arrayEqual&apos;) {
  if (actual.length !== expected.length) {
    throw new Error(message);
  }

  for (let i = 0; i &lt; expected.length; i += 1) {
    if (expected[i] !== actual[i]) {
      throw new Error(message);
    }
  }
};
/* eslint-enable no-undef, global-require */


function inspect(x) {
  if (x &amp;&amp; typeof x.inspect === &apos;function&apos;) {
    return x.inspect();
  }

  function inspectFn(f) {
    return f.name ? f.name : f.toString();
  }

  function inspectTerm(t) {
    switch (typeof t) {
      case &apos;string&apos;:
        return `&apos;${t}&apos;`;
      case &apos;object&apos;: {
        const ts = Object.keys(t).map(k =&gt; [k, inspect(t[k])]);
        return `{${ts.map(kv =&gt; kv.join(&apos;: &apos;)).join(&apos;, &apos;)}}`;
      }
      default:
        return String(t);
    }
  }

  function inspectArgs(args) {
    return Array.isArray(args) ? `[${args.map(inspect).join(&apos;, &apos;)}]` : inspectTerm(args);
  }

  return (typeof x === &apos;function&apos;) ? inspectFn(x) : inspectArgs(x);
}


/* eslint-disable no-param-reassign */
function withSpyOn(prop, obj, fn) {
  const orig = obj[prop];
  let called = false;
  obj[prop] = function spy(...args) {
    called = true;
    return orig.call(this, ...args);
  };
  fn();
  obj[prop] = orig;
  return called;
}
/* eslint-enable no-param-reassign */


const typeMismatch = (src, got, fn) =&gt; `Type Mismatch in function &apos;${fn}&apos;

        ${fn} :: ${got}

      instead of

        ${fn} :: ${src}`;


const capitalize = s =&gt; `${s[0].toUpperCase()}${s.substring(1)}`;


const ordinal = (i) =&gt; {
  switch (i) {
    case 1:
      return &apos;1st&apos;;
    case 2:
      return &apos;2nd&apos;;
    case 3:
      return &apos;3rd&apos;;
    default:
      return `${i}th`; // NOTE won&apos;t get any much bigger ...
  }
};

const getType = (x) =&gt; {
  if (x === null) {
    return &apos;Null&apos;;
  }

  if (typeof x === &apos;undefined&apos;) {
    return &apos;()&apos;;
  }

  if (Array.isArray(x)) {
    return `[${x[0] ? getType(x[0]) : &apos;?&apos;}]`;
  }

  if (typeof x.getType === &apos;function&apos;) {
    return x.getType();
  }

  if (x.constructor &amp;&amp; x.constructor.name) {
    return x.constructor.name;
  }

  return capitalize(typeof x);
};


/* ---------- Essential FP Functions ---------- */

// NOTE A slightly pumped up version of `curry` which also keeps track of
// whether a function was called partially or with all its arguments at once.
// This is useful to provide insights during validation of exercises.
function curry(fn) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;function -&gt; ?&apos;, [getType(fn), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;curry&apos;),
  );

  const arity = fn.length;

  return namedAs(fn.name, function $curry(...args) {
    $curry.partially = this &amp;&amp; this.partially;

    if (args.length &lt; arity) {
      return namedAs(fn.name, $curry.bind({ partially: true }, ...args));
    }

    return fn.call(this || { partially: false }, ...args);
  });
}


// NOTE A slightly pumped up version of `compose` which also keeps track of the chain
// of callees. In the end, a function created with `compose` holds a `callees` variable
// with the list of all the callees&apos; names.
// This is useful to provide insights during validation of exercises
function compose(...fns) {
  const n = fns.length;

  return function $compose(...args) {
    $compose.callees = [];

    let $args = args;

    for (let i = n - 1; i &gt;= 0; i -= 1) {
      const fn = fns[i];

      assert(
        typeof fn === &apos;function&apos;,
        `Invalid Composition: ${ordinal(n - i)} element in a composition isn&apos;t a function`,
      );

      $compose.callees.push(fn.name);
      $args = [fn.call(null, ...$args)];
    }

    return $args[0];
  };
}


/* ---------- Algebraic Data Structures ---------- */

class Either {
  static of(x) {
    return new Right(x); // eslint-disable-line no-use-before-define
  }

  constructor(x) {
    this.$value = x;
  }
}


class Left extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return true;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return false;
  }

  ap() {
    return this;
  }

  chain() {
    return this;
  }

  inspect() {
    return `Left(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ${getType(this.$value)} ?)`;
  }

  join() {
    return this;
  }

  map() {
    return this;
  }

  sequence(of) {
    return of(this);
  }

  traverse(of, fn) {
    return of(this);
  }
}


class Right extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return false;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return true;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return fn(this.$value);
  }

  inspect() {
    return `Right(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ? ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Either.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    fn(this.$value).map(Either.of);
  }
}


class Identity {
  static of(x) {
    return new Identity(x);
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `Identity(${inspect(this.$value)})`;
  }

  getType() {
    return `(Identity ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Identity.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return fn(this.$value).map(Identity.of);
  }
}

class IO {
  static of(x) {
    return new IO(() =&gt; x);
  }

  constructor(io) {
    assert(
      typeof io === &apos;function&apos;,
      &apos;invalid `io` operation given to IO constructor. Use `IO.of` if you want to lift a value in a default minimal IO context.&apos;,
    );

    this.unsafePerformIO = io;
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `IO(${inspect(this.unsafePerformIO())})`;
  }

  getType() {
    return `(IO ${getType(this.unsafePerformIO())})`;
  }


  join() {
    return this.unsafePerformIO();
  }

  map(fn) {
    return new IO(compose(fn, this.unsafePerformIO));
  }
}


class Map {
  constructor(x) {
    assert(
      typeof x === &apos;object&apos; &amp;&amp; x !== null,
      &apos;tried to create `Map` with non object-like&apos;,
    );

    this.$value = x;
  }

  inspect() {
    return `Map(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[Object.keys(this.$value)[0]];

    return `(Map String ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  insert(k, v) {
    const singleton = {};
    singleton[k] = v;
    return new Map(Object.assign({}, this.$value, singleton));
  }

  reduce(fn, zero) {
    return this.reduceWithKeys((acc, _, k) =&gt; fn(acc, k), zero);
  }

  reduceWithKeys(fn, zero) {
    return Object.keys(this.$value)
      .reduce((acc, k) =&gt; fn(acc, this.$value[k], k), zero);
  }

  map(fn) {
    return new Map(this.reduceWithKeys((obj, v, k) =&gt; {
      obj[k] = fn(v); // eslint-disable-line no-param-reassign
      return obj;
    }, {}));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.reduceWithKeys(
      (f, a, k) =&gt; fn(a).map(b =&gt; m =&gt; m.insert(k, b)).ap(f),
      of(new Map({})),
    );
  }
}


class List {
  static of(x) {
    return new List([x]);
  }

  constructor(xs) {
    assert(
      Array.isArray(xs),
      &apos;tried to create `List` from non-array&apos;,
    );

    this.$value = xs;
  }

  concat(x) {
    return new List(this.$value.concat(x));
  }

  inspect() {
    return `List(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[0];

    return `(List ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  map(fn) {
    return new List(this.$value.map(fn));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.$value.reduce(
      (f, a) =&gt; fn(a).map(b =&gt; bs =&gt; bs.concat(b)).ap(f),
      of(new List([])),
    );
  }
}


class Maybe {
  static of(x) {
    return new Maybe(x);
  }

  get isNothing() {
    return this.$value === null || this.$value === undefined;
  }

  get isJust() {
    return !this.isNothing;
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return this.isNothing ? this : f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return this.isNothing ? &apos;Nothing&apos; : `Just(${inspect(this.$value)})`;
  }

  getType() {
    return `(Maybe ${this.isJust ? getType(this.$value) : &apos;?&apos;})`;
  }

  join() {
    return this.isNothing ? this : this.$value;
  }

  map(fn) {
    return this.isNothing ? this : Maybe.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.isNothing ? of(this) : fn(this.$value).map(Maybe.of);
  }
}


class Task {
  constructor(fork) {
    assert(
      typeof fork === &apos;function&apos;,
      &apos;invalid `fork` operation given to Task constructor. Use `Task.of` if you want to lift a value in a default minimal Task context.&apos;,
    );

    this.fork = fork;
  }

  static of(x) {
    return new Task((_, resolve) =&gt; resolve(x));
  }

  static rejected(x) {
    return new Task((reject, _) =&gt; reject(x));
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, x =&gt; fn(x).fork(reject, resolve)));
  }

  inspect() { // eslint-disable-line class-methods-use-this
    return &apos;Task(?)&apos;;
  }

  getType() { // eslint-disable-line class-methods-use-this
    return &apos;(Task ? ?)&apos;;
  }

  join() {
    return this.chain(x =&gt; x);
  }

  map(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, compose(resolve, fn)));
  }
}

// In nodejs the existance of a class method named `inspect` will trigger a deprecation warning
// when passing an instance to `console.log`:
// `(node:3845) [DEP0079] DeprecationWarning: Custom inspection function on Objects via .inspect() is deprecated`
// The solution is to alias the existing inspect method with the special inspect symbol exported by node
if (typeof module !== &apos;undefined&apos; &amp;&amp; typeof this !== &apos;undefined&apos; &amp;&amp; this.module !== module) {
  const customInspect = require(&apos;util&apos;).inspect.custom;
  const assignCustomInspect = it =&gt; it.prototype[customInspect] = it.prototype.inspect;
  [Left, Right, Identity, IO, Map, List, Maybe, Task].forEach(assignCustomInspect);
}

const identity = function identity(x) { return x; };

const either = curry(function either(f, g, e) {
  if (e.isLeft) {
    return f(e.$value);
  }

  return g(e.$value);
});

const left = function left(x) { return new Left(x); };

const maybe = curry(function maybe(v, f, m) {
  if (m.isNothing) {
    return v;
  }

  return f(m.$value);
});

const nothing = Maybe.of(null);

const reject = function reject(x) { return Task.rejected(x); };

const chain = curry(function chain(fn, m) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m a&apos;, [getType(fn), getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;chain&apos;),
  );

  return m.chain(fn);
});

const join = function join(m) {
  assert(
    typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; m (m a) -&gt; m a&apos;, [getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;join&apos;),
  );

  return m.join();
};

const map = curry(function map(fn, f) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof f.map === &apos;function&apos;,
    typeMismatch(&apos;Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b&apos;, [getType(fn), getType(f), &apos;f b&apos;].join(&apos; -&gt; &apos;), &apos;map&apos;),
  );

  return f.map(fn);
});

const sequence = curry(function sequence(of, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof x.sequence === &apos;function&apos;,
    typeMismatch(&apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; t (f a) -&gt; f (t a)&apos;, [getType(of), getType(x), &apos;f (t a)&apos;].join(&apos; -&gt; &apos;), &apos;sequence&apos;),
  );

  return x.sequence(of);
});

const traverse = curry(function traverse(of, fn, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof fn === &apos;function&apos; &amp;&amp; typeof x.traverse === &apos;function&apos;,
    typeMismatch(
      &apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)&apos;,
      [getType(of), getType(fn), getType(x), &apos;f (t b)&apos;].join(&apos; -&gt; &apos;),
      &apos;traverse&apos;,
    ),
  );

  return x.traverse(of, fn);
});

const unsafePerformIO = function unsafePerformIO(io) {
  assert(
    io instanceof IO,
    typeMismatch(&apos;IO a&apos;, getType(io), &apos;unsafePerformIO&apos;),
  );

  return io.unsafePerformIO();
};

const liftA2 = curry(function liftA2(fn, a1, a2) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2);
});

const liftA3 = curry(function liftA3(fn, a1, a2, a3) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;
      &amp;&amp; typeof a3.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2).ap(a3);
});

const always = curry(function always(a, b) { return a; });


/* ---------- Pointfree Classic Utilities ---------- */

const append = curry(function append(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return b.concat(a);
});

const add = curry(function add(a, b) {
  assert(
    typeof a === &apos;number&apos; &amp;&amp; typeof b === &apos;number&apos;,
    typeMismatch(&apos;Number -&gt; Number -&gt; Number&apos;, [getType(a), getType(b), &apos;Number&apos;].join(&apos; -&gt; &apos;), &apos;add&apos;),
  );

  return a + b;
});

const concat = curry(function concat(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return a.concat(b);
});

const eq = curry(function eq(a, b) {
  assert(
    getType(a) === getType(b),
    typeMismatch(&apos;a -&gt; a -&gt; Boolean&apos;, [getType(a), getType(b), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), eq),
  );

  return a === b;
});

const filter = curry(function filter(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; Boolean) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;filter&apos;),
  );

  return xs.filter(fn);
});

const flip = curry(function flip(fn, a, b) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;(a -&gt; b) -&gt; (b -&gt; a)&apos;, [getType(fn), &apos;(b -&gt; a)&apos;].join(&apos; -&gt; &apos;), &apos;flip&apos;),
  );

  return fn(b, a);
});

const forEach = curry(function forEach(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; ()) -&gt; [a] -&gt; ()&apos;, [getType(fn), getType(xs), &apos;()&apos;].join(&apos; -&gt; &apos;), &apos;forEach&apos;),
  );

  xs.forEach(fn);
});

const intercalate = curry(function intercalate(str, xs) {
  assert(
    typeof str === &apos;string&apos; &amp;&amp; Array.isArray(xs) &amp;&amp; (xs.length === 0 || typeof xs[0] === &apos;string&apos;),
    typeMismatch(&apos;String -&gt; [String] -&gt; String&apos;, [getType(str), getType(xs), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;intercalate&apos;),
  );

  return xs.join(str);
});

const head = function head(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;head&apos;),
  );

  return xs[0];
};

const last = function last(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;last&apos;),
  );

  return xs[xs.length - 1];
};

const match = curry(function match(re, str) {
  assert(
    re instanceof RegExp &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;RegExp -&gt; String -&gt; Boolean&apos;, [getType(re), getType(str), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), &apos;match&apos;),
  );

  return re.test(str);
});

const prop = curry(function prop(p, obj) {
  assert(
    typeof p === &apos;string&apos; &amp;&amp; typeof obj === &apos;object&apos; &amp;&amp; obj !== null,
    typeMismatch(&apos;String -&gt; Object -&gt; a&apos;, [getType(p), getType(obj), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;prop&apos;),
  );

  return obj[p];
});

const reduce = curry(function reduce(fn, zero, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b&apos;, [getType(fn), getType(zero), getType(xs), &apos;b&apos;].join(&apos; -&gt; &apos;), &apos;reduce&apos;),
  );

  return xs.reduce(
    function $reduceIterator($acc, $x) { return fn($acc, $x); },
    zero,
  );
});

const safeHead = namedAs(&apos;safeHead&apos;, compose(Maybe.of, head));

const safeProp = curry(function safeProp(p, obj) { return Maybe.of(prop(p, obj)); });

const sortBy = curry(function sortBy(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), &apos;[a]&apos;].join(&apos; -&gt; &apos;), &apos;sortBy&apos;),
  );

  return xs.sort((a, b) =&gt; {
    if (fn(a) === fn(b)) {
      return 0;
    }

    return fn(a) &gt; fn(b) ? 1 : -1;
  });
});

const split = curry(function split(s, str) {
  assert(
    typeof s === &apos;string&apos; &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; [String]&apos;, [getType(s), getType(str), &apos;[String]&apos;].join(&apos; -&gt; &apos;), &apos;split&apos;),
  );

  return str.split(s);
});

const take = curry(function take(n, xs) {
  assert(
    typeof n === &apos;number&apos; &amp;&amp; (Array.isArray(xs) || typeof xs === &apos;string&apos;),
    typeMismatch(&apos;Number -&gt; [a] -&gt; [a]&apos;, [getType(n), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;take&apos;),
  );

  return xs.slice(0, n);
});

const toLowerCase = function toLowerCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toLowerCase();
};

const toUpperCase = function toUpperCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toUpperCase();
};


/* ---------- Chapter 4 ---------- */

const keepHighest = function keepHighest(x, y) {
  try {
    keepHighest.calledBy = keepHighest.caller;
  } catch (err) {
    // NOTE node.js runs in strict mode and prohibit the usage of &apos;.caller&apos;
    // There&apos;s a ugly hack to retrieve the caller from stack trace.
    const [, caller] = /at (\S+)/.exec(err.stack.split(&apos;\n&apos;)[2]);

    keepHighest.calledBy = namedAs(caller, () =&gt; {});
  }

  return x &gt;= y ? x : y;
};


/* ---------- Chapter 5 ---------- */

const cars = [{
  name: &apos;Ferrari FF&apos;,
  horsepower: 660,
  dollar_value: 700000,
  in_stock: true,
}, {
  name: &apos;Spyker C12 Zagato&apos;,
  horsepower: 650,
  dollar_value: 648000,
  in_stock: false,
}, {
  name: &apos;Jaguar XKR-S&apos;,
  horsepower: 550,
  dollar_value: 132000,
  in_stock: true,
}, {
  name: &apos;Audi R8&apos;,
  horsepower: 525,
  dollar_value: 114200,
  in_stock: false,
}, {
  name: &apos;Aston Martin One-77&apos;,
  horsepower: 750,
  dollar_value: 1850000,
  in_stock: true,
}, {
  name: &apos;Pagani Huayra&apos;,
  horsepower: 700,
  dollar_value: 1300000,
  in_stock: false,
}];

const average = function average(xs) {
  return xs.reduce(add, 0) / xs.length;
};


/* ---------- Chapter 8 ---------- */

const albert = {
  id: 1,
  active: true,
  name: &apos;Albert&apos;,
  address: {
    street: {
      number: 22,
      name: &apos;Walnut St&apos;,
    },
  },
};

const gary = {
  id: 2,
  active: false,
  name: &apos;Gary&apos;,
  address: {
    street: {
      number: 14,
    },
  },
};

const theresa = {
  id: 3,
  active: true,
  name: &apos;Theresa&apos;,
};

const yi = { id: 4, name: &apos;Yi&apos;, active: true };

const showWelcome = namedAs(&apos;showWelcome&apos;, compose(concat(&apos;Welcome &apos;), prop(&apos;name&apos;)));

const checkActive = function checkActive(user) {
  return user.active
    ? Either.of(user)
    : left(&apos;Your account is not active&apos;);
};

const save = function save(user) {
  return new IO(() =&gt; Object.assign({}, user, { saved: true }));
};

const validateUser = curry(function validateUser(validate, user) {
  return validate(user).map(_ =&gt; user); // eslint-disable-line no-unused-vars
});


/* ---------- Chapter 9 ---------- */

const getFile = IO.of(&apos;/home/mostly-adequate/ch09.md&apos;);

const pureLog = function pureLog(str) { return new IO(() =&gt; { console.log(str); return str; }); };

const addToMailingList = function addToMailingList(email) { return IO.of([email]); };

const emailBlast = function emailBlast(list) { return IO.of(list.join(&apos;,&apos;)); };

const validateEmail = function validateEmail(x) {
  return /\S+@\S+\.\S+/.test(x)
    ? Either.of(x)
    : left(&apos;invalid email&apos;);
};


/* ---------- Chapter 10 ---------- */

const localStorage = { player1: albert, player2: theresa };

const game = curry(function game(p1, p2) { return `${p1.name} vs ${p2.name}`; });

const getFromCache = function getFromCache(x) { return new IO(() =&gt; localStorage[x]); };


/* ---------- Chapter 11 ---------- */

const findUserById = function findUserById(id) {
  switch (id) {
    case 1:
      return Task.of(Either.of(albert));

    case 2:
      return Task.of(Either.of(gary));

    case 3:
      return Task.of(Either.of(theresa));

    default:
      return Task.of(left(&apos;not found&apos;));
  }
};

const eitherToTask = namedAs(&apos;eitherToTask&apos;, either(Task.rejected, Task.of));


/* ---------- Chapter 12 ---------- */

const httpGet = function httpGet(route) { return Task.of(`json for ${route}`); };

const routes = new Map({
  &apos;/&apos;: &apos;/&apos;,
  &apos;/about&apos;: &apos;/about&apos;,
});

const validate = function validate(player) {
  return player.name
    ? Either.of(player)
    : left(&apos;must have name&apos;);
};

const readdir = function readdir(dir) {
  return Task.of([&apos;file1&apos;, &apos;file2&apos;, &apos;file3&apos;]);
};

const readfile = curry(function readfile(encoding, file) {
  return Task.of(`content of ${file} (${encoding})`);
});


/* ---------- Exports ---------- */

if (typeof module === &apos;object&apos;) {
  module.exports = {
    // Utils
    withSpyOn,

    // Essential FP helpers
    always,
    compose,
    curry,
    either,
    identity,
    inspect,
    left,
    liftA2,
    liftA3,
    maybe,
    nothing,
    reject,

    // Algebraic Data Structures
    Either,
    IO,
    Identity,
    Left,
    List,
    Map,
    Maybe,
    Right,
    Task,

    // Currified version of &apos;standard&apos; functions
    append,
    add,
    chain,
    concat,
    eq,
    filter,
    flip,
    forEach,
    head,
    intercalate,
    join,
    last,
    map,
    match,
    prop,
    reduce,
    safeHead,
    safeProp,
    sequence,
    sortBy,
    split,
    take,
    toLowerCase,
    toUpperCase,
    traverse,
    unsafePerformIO,

    // Chapter 04
    keepHighest,

    // Chapter 05
    cars,
    average,

    // Chapter 08
    albert,
    gary,
    theresa,
    yi,
    showWelcome,
    checkActive,
    save,
    validateUser,

    // Chapter 09
    getFile,
    pureLog,
    addToMailingList,
    emailBlast,
    validateEmail,

    // Chapter 10
    localStorage,
    getFromCache,
    game,

    // Chapter 11
    findUserById,
    eitherToTask,

    // Chapter 12
    httpGet,
    routes,
    validate,
    readdir,
    readfile,
  };
}</pre>
	

	<div class="buttons">
	    <a href="#" class="button size-2 action-submit">Submit</a>
	    <a href="#" class="button size-2 action-solution">Solution</a>
	</div>
</div>  </p>
<hr>
<pre><code class="lang-js"><span class="hljs-comment">// eitherToTask :: Either a b -&gt; Task a b</span>
<span class="hljs-keyword">const</span> eitherToTask = either(Task.rejected, Task.of);
</code></pre>
<p><div class="exercise">
	<div class="header">Exercise</div>
	<div class="alert alert-success">
	    <b>Correct!</b>
	</div>

	<div class="alert alert-danger error-message">
	    <b>False!</b>
	</div>

	<div class="message">
	  
Using `eitherToTask`, simplify `findNameById` to remove the nested `Either`.
  

	</div>
	<div class="editor" style="height: 20px">// findNameById :: Number -&gt; Task Error (Either Error User)
const findNameById = compose(map(map(prop(&apos;name&apos;))), findUserById);</div>

	<pre class="hidden code-solution">const findNameById = compose(map(prop(&apos;name&apos;)), chain(eitherToTask), findUserById);</pre>
	<pre class="hidden code-validation">/* globals findNameById */

const throwUnexpected = () =&gt; {
  throw new Error(&apos;The function gives incorrect results; a Task has resolved unexpectedly!&apos;);
};

const res = findNameById(1);

assert(
  res instanceof Task,
  &apos;The function has an incorrect type; hint: `findNameById` must return a `Task String User`!&apos;,
);

res.fork(throwUnexpected, (val) =&gt; {
  assert(
    !(val instanceof Task),
    &apos;The function has an incorrect type; hint: `findNameById` must return a `Task String User`, make sure to flatten any nested Functor!&apos;,
  );

  assert(
    !(val instanceof Either),
    &apos;The function has an incorrect type; hint: did you use `eitherToTask` ?&apos;,
  );

  assert(
    val === &apos;Albert&apos;,
    &apos;The function gives incorrect results for the `Right` side of `Either`.&apos;,
  );
});


const rej = findNameById(999);

assert(
  rej instanceof Task,
  &apos;The function has an incorrect type; hint: `findNameById` must return a `Task String User`!&apos;,
);

rej.fork((val) =&gt; {
  assert(
    !(val instanceof Task),
    &apos;The function has an incorrect type; hint: `findNameById` must return a `Task String User`, make sure to flatten any nested Functor!&apos;,
  );

  assert(
    val === &apos;not found&apos;,
    &apos;The function gives incorrect results for the `Left` side of `Either`.&apos;,
  );
}, throwUnexpected);</pre>
	
	<pre class="hidden code-context">// NOTE We keep named function here to leverage this in the `compose` function,
// and later on in the validations scripts.

/* eslint-disable prefer-arrow-callback */


/* ---------- Internals ---------- */

function namedAs(value, fn) {
  Object.defineProperty(fn, &apos;name&apos;, { value });
  return fn;
}


// NOTE This file is loaded by gitbook&apos;s exercises plugin. When it does, there&apos;s an
// `assert` function available in the global scope.

/* eslint-disable no-undef, global-require */
if (typeof assert !== &apos;function&apos; &amp;&amp; typeof require === &apos;function&apos;) {
  global.assert = require(&apos;assert&apos;);
}

assert.arrayEqual = function assertArrayEqual(actual, expected, message = &apos;arrayEqual&apos;) {
  if (actual.length !== expected.length) {
    throw new Error(message);
  }

  for (let i = 0; i &lt; expected.length; i += 1) {
    if (expected[i] !== actual[i]) {
      throw new Error(message);
    }
  }
};
/* eslint-enable no-undef, global-require */


function inspect(x) {
  if (x &amp;&amp; typeof x.inspect === &apos;function&apos;) {
    return x.inspect();
  }

  function inspectFn(f) {
    return f.name ? f.name : f.toString();
  }

  function inspectTerm(t) {
    switch (typeof t) {
      case &apos;string&apos;:
        return `&apos;${t}&apos;`;
      case &apos;object&apos;: {
        const ts = Object.keys(t).map(k =&gt; [k, inspect(t[k])]);
        return `{${ts.map(kv =&gt; kv.join(&apos;: &apos;)).join(&apos;, &apos;)}}`;
      }
      default:
        return String(t);
    }
  }

  function inspectArgs(args) {
    return Array.isArray(args) ? `[${args.map(inspect).join(&apos;, &apos;)}]` : inspectTerm(args);
  }

  return (typeof x === &apos;function&apos;) ? inspectFn(x) : inspectArgs(x);
}


/* eslint-disable no-param-reassign */
function withSpyOn(prop, obj, fn) {
  const orig = obj[prop];
  let called = false;
  obj[prop] = function spy(...args) {
    called = true;
    return orig.call(this, ...args);
  };
  fn();
  obj[prop] = orig;
  return called;
}
/* eslint-enable no-param-reassign */


const typeMismatch = (src, got, fn) =&gt; `Type Mismatch in function &apos;${fn}&apos;

        ${fn} :: ${got}

      instead of

        ${fn} :: ${src}`;


const capitalize = s =&gt; `${s[0].toUpperCase()}${s.substring(1)}`;


const ordinal = (i) =&gt; {
  switch (i) {
    case 1:
      return &apos;1st&apos;;
    case 2:
      return &apos;2nd&apos;;
    case 3:
      return &apos;3rd&apos;;
    default:
      return `${i}th`; // NOTE won&apos;t get any much bigger ...
  }
};

const getType = (x) =&gt; {
  if (x === null) {
    return &apos;Null&apos;;
  }

  if (typeof x === &apos;undefined&apos;) {
    return &apos;()&apos;;
  }

  if (Array.isArray(x)) {
    return `[${x[0] ? getType(x[0]) : &apos;?&apos;}]`;
  }

  if (typeof x.getType === &apos;function&apos;) {
    return x.getType();
  }

  if (x.constructor &amp;&amp; x.constructor.name) {
    return x.constructor.name;
  }

  return capitalize(typeof x);
};


/* ---------- Essential FP Functions ---------- */

// NOTE A slightly pumped up version of `curry` which also keeps track of
// whether a function was called partially or with all its arguments at once.
// This is useful to provide insights during validation of exercises.
function curry(fn) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;function -&gt; ?&apos;, [getType(fn), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;curry&apos;),
  );

  const arity = fn.length;

  return namedAs(fn.name, function $curry(...args) {
    $curry.partially = this &amp;&amp; this.partially;

    if (args.length &lt; arity) {
      return namedAs(fn.name, $curry.bind({ partially: true }, ...args));
    }

    return fn.call(this || { partially: false }, ...args);
  });
}


// NOTE A slightly pumped up version of `compose` which also keeps track of the chain
// of callees. In the end, a function created with `compose` holds a `callees` variable
// with the list of all the callees&apos; names.
// This is useful to provide insights during validation of exercises
function compose(...fns) {
  const n = fns.length;

  return function $compose(...args) {
    $compose.callees = [];

    let $args = args;

    for (let i = n - 1; i &gt;= 0; i -= 1) {
      const fn = fns[i];

      assert(
        typeof fn === &apos;function&apos;,
        `Invalid Composition: ${ordinal(n - i)} element in a composition isn&apos;t a function`,
      );

      $compose.callees.push(fn.name);
      $args = [fn.call(null, ...$args)];
    }

    return $args[0];
  };
}


/* ---------- Algebraic Data Structures ---------- */

class Either {
  static of(x) {
    return new Right(x); // eslint-disable-line no-use-before-define
  }

  constructor(x) {
    this.$value = x;
  }
}


class Left extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return true;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return false;
  }

  ap() {
    return this;
  }

  chain() {
    return this;
  }

  inspect() {
    return `Left(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ${getType(this.$value)} ?)`;
  }

  join() {
    return this;
  }

  map() {
    return this;
  }

  sequence(of) {
    return of(this);
  }

  traverse(of, fn) {
    return of(this);
  }
}


class Right extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return false;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return true;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return fn(this.$value);
  }

  inspect() {
    return `Right(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ? ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Either.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    fn(this.$value).map(Either.of);
  }
}


class Identity {
  static of(x) {
    return new Identity(x);
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `Identity(${inspect(this.$value)})`;
  }

  getType() {
    return `(Identity ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Identity.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return fn(this.$value).map(Identity.of);
  }
}

class IO {
  static of(x) {
    return new IO(() =&gt; x);
  }

  constructor(io) {
    assert(
      typeof io === &apos;function&apos;,
      &apos;invalid `io` operation given to IO constructor. Use `IO.of` if you want to lift a value in a default minimal IO context.&apos;,
    );

    this.unsafePerformIO = io;
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `IO(${inspect(this.unsafePerformIO())})`;
  }

  getType() {
    return `(IO ${getType(this.unsafePerformIO())})`;
  }


  join() {
    return this.unsafePerformIO();
  }

  map(fn) {
    return new IO(compose(fn, this.unsafePerformIO));
  }
}


class Map {
  constructor(x) {
    assert(
      typeof x === &apos;object&apos; &amp;&amp; x !== null,
      &apos;tried to create `Map` with non object-like&apos;,
    );

    this.$value = x;
  }

  inspect() {
    return `Map(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[Object.keys(this.$value)[0]];

    return `(Map String ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  insert(k, v) {
    const singleton = {};
    singleton[k] = v;
    return new Map(Object.assign({}, this.$value, singleton));
  }

  reduce(fn, zero) {
    return this.reduceWithKeys((acc, _, k) =&gt; fn(acc, k), zero);
  }

  reduceWithKeys(fn, zero) {
    return Object.keys(this.$value)
      .reduce((acc, k) =&gt; fn(acc, this.$value[k], k), zero);
  }

  map(fn) {
    return new Map(this.reduceWithKeys((obj, v, k) =&gt; {
      obj[k] = fn(v); // eslint-disable-line no-param-reassign
      return obj;
    }, {}));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.reduceWithKeys(
      (f, a, k) =&gt; fn(a).map(b =&gt; m =&gt; m.insert(k, b)).ap(f),
      of(new Map({})),
    );
  }
}


class List {
  static of(x) {
    return new List([x]);
  }

  constructor(xs) {
    assert(
      Array.isArray(xs),
      &apos;tried to create `List` from non-array&apos;,
    );

    this.$value = xs;
  }

  concat(x) {
    return new List(this.$value.concat(x));
  }

  inspect() {
    return `List(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[0];

    return `(List ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  map(fn) {
    return new List(this.$value.map(fn));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.$value.reduce(
      (f, a) =&gt; fn(a).map(b =&gt; bs =&gt; bs.concat(b)).ap(f),
      of(new List([])),
    );
  }
}


class Maybe {
  static of(x) {
    return new Maybe(x);
  }

  get isNothing() {
    return this.$value === null || this.$value === undefined;
  }

  get isJust() {
    return !this.isNothing;
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return this.isNothing ? this : f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return this.isNothing ? &apos;Nothing&apos; : `Just(${inspect(this.$value)})`;
  }

  getType() {
    return `(Maybe ${this.isJust ? getType(this.$value) : &apos;?&apos;})`;
  }

  join() {
    return this.isNothing ? this : this.$value;
  }

  map(fn) {
    return this.isNothing ? this : Maybe.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.isNothing ? of(this) : fn(this.$value).map(Maybe.of);
  }
}


class Task {
  constructor(fork) {
    assert(
      typeof fork === &apos;function&apos;,
      &apos;invalid `fork` operation given to Task constructor. Use `Task.of` if you want to lift a value in a default minimal Task context.&apos;,
    );

    this.fork = fork;
  }

  static of(x) {
    return new Task((_, resolve) =&gt; resolve(x));
  }

  static rejected(x) {
    return new Task((reject, _) =&gt; reject(x));
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, x =&gt; fn(x).fork(reject, resolve)));
  }

  inspect() { // eslint-disable-line class-methods-use-this
    return &apos;Task(?)&apos;;
  }

  getType() { // eslint-disable-line class-methods-use-this
    return &apos;(Task ? ?)&apos;;
  }

  join() {
    return this.chain(x =&gt; x);
  }

  map(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, compose(resolve, fn)));
  }
}

// In nodejs the existance of a class method named `inspect` will trigger a deprecation warning
// when passing an instance to `console.log`:
// `(node:3845) [DEP0079] DeprecationWarning: Custom inspection function on Objects via .inspect() is deprecated`
// The solution is to alias the existing inspect method with the special inspect symbol exported by node
if (typeof module !== &apos;undefined&apos; &amp;&amp; typeof this !== &apos;undefined&apos; &amp;&amp; this.module !== module) {
  const customInspect = require(&apos;util&apos;).inspect.custom;
  const assignCustomInspect = it =&gt; it.prototype[customInspect] = it.prototype.inspect;
  [Left, Right, Identity, IO, Map, List, Maybe, Task].forEach(assignCustomInspect);
}

const identity = function identity(x) { return x; };

const either = curry(function either(f, g, e) {
  if (e.isLeft) {
    return f(e.$value);
  }

  return g(e.$value);
});

const left = function left(x) { return new Left(x); };

const maybe = curry(function maybe(v, f, m) {
  if (m.isNothing) {
    return v;
  }

  return f(m.$value);
});

const nothing = Maybe.of(null);

const reject = function reject(x) { return Task.rejected(x); };

const chain = curry(function chain(fn, m) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m a&apos;, [getType(fn), getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;chain&apos;),
  );

  return m.chain(fn);
});

const join = function join(m) {
  assert(
    typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; m (m a) -&gt; m a&apos;, [getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;join&apos;),
  );

  return m.join();
};

const map = curry(function map(fn, f) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof f.map === &apos;function&apos;,
    typeMismatch(&apos;Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b&apos;, [getType(fn), getType(f), &apos;f b&apos;].join(&apos; -&gt; &apos;), &apos;map&apos;),
  );

  return f.map(fn);
});

const sequence = curry(function sequence(of, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof x.sequence === &apos;function&apos;,
    typeMismatch(&apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; t (f a) -&gt; f (t a)&apos;, [getType(of), getType(x), &apos;f (t a)&apos;].join(&apos; -&gt; &apos;), &apos;sequence&apos;),
  );

  return x.sequence(of);
});

const traverse = curry(function traverse(of, fn, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof fn === &apos;function&apos; &amp;&amp; typeof x.traverse === &apos;function&apos;,
    typeMismatch(
      &apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)&apos;,
      [getType(of), getType(fn), getType(x), &apos;f (t b)&apos;].join(&apos; -&gt; &apos;),
      &apos;traverse&apos;,
    ),
  );

  return x.traverse(of, fn);
});

const unsafePerformIO = function unsafePerformIO(io) {
  assert(
    io instanceof IO,
    typeMismatch(&apos;IO a&apos;, getType(io), &apos;unsafePerformIO&apos;),
  );

  return io.unsafePerformIO();
};

const liftA2 = curry(function liftA2(fn, a1, a2) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2);
});

const liftA3 = curry(function liftA3(fn, a1, a2, a3) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;
      &amp;&amp; typeof a3.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2).ap(a3);
});

const always = curry(function always(a, b) { return a; });


/* ---------- Pointfree Classic Utilities ---------- */

const append = curry(function append(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return b.concat(a);
});

const add = curry(function add(a, b) {
  assert(
    typeof a === &apos;number&apos; &amp;&amp; typeof b === &apos;number&apos;,
    typeMismatch(&apos;Number -&gt; Number -&gt; Number&apos;, [getType(a), getType(b), &apos;Number&apos;].join(&apos; -&gt; &apos;), &apos;add&apos;),
  );

  return a + b;
});

const concat = curry(function concat(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return a.concat(b);
});

const eq = curry(function eq(a, b) {
  assert(
    getType(a) === getType(b),
    typeMismatch(&apos;a -&gt; a -&gt; Boolean&apos;, [getType(a), getType(b), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), eq),
  );

  return a === b;
});

const filter = curry(function filter(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; Boolean) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;filter&apos;),
  );

  return xs.filter(fn);
});

const flip = curry(function flip(fn, a, b) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;(a -&gt; b) -&gt; (b -&gt; a)&apos;, [getType(fn), &apos;(b -&gt; a)&apos;].join(&apos; -&gt; &apos;), &apos;flip&apos;),
  );

  return fn(b, a);
});

const forEach = curry(function forEach(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; ()) -&gt; [a] -&gt; ()&apos;, [getType(fn), getType(xs), &apos;()&apos;].join(&apos; -&gt; &apos;), &apos;forEach&apos;),
  );

  xs.forEach(fn);
});

const intercalate = curry(function intercalate(str, xs) {
  assert(
    typeof str === &apos;string&apos; &amp;&amp; Array.isArray(xs) &amp;&amp; (xs.length === 0 || typeof xs[0] === &apos;string&apos;),
    typeMismatch(&apos;String -&gt; [String] -&gt; String&apos;, [getType(str), getType(xs), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;intercalate&apos;),
  );

  return xs.join(str);
});

const head = function head(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;head&apos;),
  );

  return xs[0];
};

const last = function last(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;last&apos;),
  );

  return xs[xs.length - 1];
};

const match = curry(function match(re, str) {
  assert(
    re instanceof RegExp &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;RegExp -&gt; String -&gt; Boolean&apos;, [getType(re), getType(str), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), &apos;match&apos;),
  );

  return re.test(str);
});

const prop = curry(function prop(p, obj) {
  assert(
    typeof p === &apos;string&apos; &amp;&amp; typeof obj === &apos;object&apos; &amp;&amp; obj !== null,
    typeMismatch(&apos;String -&gt; Object -&gt; a&apos;, [getType(p), getType(obj), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;prop&apos;),
  );

  return obj[p];
});

const reduce = curry(function reduce(fn, zero, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b&apos;, [getType(fn), getType(zero), getType(xs), &apos;b&apos;].join(&apos; -&gt; &apos;), &apos;reduce&apos;),
  );

  return xs.reduce(
    function $reduceIterator($acc, $x) { return fn($acc, $x); },
    zero,
  );
});

const safeHead = namedAs(&apos;safeHead&apos;, compose(Maybe.of, head));

const safeProp = curry(function safeProp(p, obj) { return Maybe.of(prop(p, obj)); });

const sortBy = curry(function sortBy(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), &apos;[a]&apos;].join(&apos; -&gt; &apos;), &apos;sortBy&apos;),
  );

  return xs.sort((a, b) =&gt; {
    if (fn(a) === fn(b)) {
      return 0;
    }

    return fn(a) &gt; fn(b) ? 1 : -1;
  });
});

const split = curry(function split(s, str) {
  assert(
    typeof s === &apos;string&apos; &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; [String]&apos;, [getType(s), getType(str), &apos;[String]&apos;].join(&apos; -&gt; &apos;), &apos;split&apos;),
  );

  return str.split(s);
});

const take = curry(function take(n, xs) {
  assert(
    typeof n === &apos;number&apos; &amp;&amp; (Array.isArray(xs) || typeof xs === &apos;string&apos;),
    typeMismatch(&apos;Number -&gt; [a] -&gt; [a]&apos;, [getType(n), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;take&apos;),
  );

  return xs.slice(0, n);
});

const toLowerCase = function toLowerCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toLowerCase();
};

const toUpperCase = function toUpperCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toUpperCase();
};


/* ---------- Chapter 4 ---------- */

const keepHighest = function keepHighest(x, y) {
  try {
    keepHighest.calledBy = keepHighest.caller;
  } catch (err) {
    // NOTE node.js runs in strict mode and prohibit the usage of &apos;.caller&apos;
    // There&apos;s a ugly hack to retrieve the caller from stack trace.
    const [, caller] = /at (\S+)/.exec(err.stack.split(&apos;\n&apos;)[2]);

    keepHighest.calledBy = namedAs(caller, () =&gt; {});
  }

  return x &gt;= y ? x : y;
};


/* ---------- Chapter 5 ---------- */

const cars = [{
  name: &apos;Ferrari FF&apos;,
  horsepower: 660,
  dollar_value: 700000,
  in_stock: true,
}, {
  name: &apos;Spyker C12 Zagato&apos;,
  horsepower: 650,
  dollar_value: 648000,
  in_stock: false,
}, {
  name: &apos;Jaguar XKR-S&apos;,
  horsepower: 550,
  dollar_value: 132000,
  in_stock: true,
}, {
  name: &apos;Audi R8&apos;,
  horsepower: 525,
  dollar_value: 114200,
  in_stock: false,
}, {
  name: &apos;Aston Martin One-77&apos;,
  horsepower: 750,
  dollar_value: 1850000,
  in_stock: true,
}, {
  name: &apos;Pagani Huayra&apos;,
  horsepower: 700,
  dollar_value: 1300000,
  in_stock: false,
}];

const average = function average(xs) {
  return xs.reduce(add, 0) / xs.length;
};


/* ---------- Chapter 8 ---------- */

const albert = {
  id: 1,
  active: true,
  name: &apos;Albert&apos;,
  address: {
    street: {
      number: 22,
      name: &apos;Walnut St&apos;,
    },
  },
};

const gary = {
  id: 2,
  active: false,
  name: &apos;Gary&apos;,
  address: {
    street: {
      number: 14,
    },
  },
};

const theresa = {
  id: 3,
  active: true,
  name: &apos;Theresa&apos;,
};

const yi = { id: 4, name: &apos;Yi&apos;, active: true };

const showWelcome = namedAs(&apos;showWelcome&apos;, compose(concat(&apos;Welcome &apos;), prop(&apos;name&apos;)));

const checkActive = function checkActive(user) {
  return user.active
    ? Either.of(user)
    : left(&apos;Your account is not active&apos;);
};

const save = function save(user) {
  return new IO(() =&gt; Object.assign({}, user, { saved: true }));
};

const validateUser = curry(function validateUser(validate, user) {
  return validate(user).map(_ =&gt; user); // eslint-disable-line no-unused-vars
});


/* ---------- Chapter 9 ---------- */

const getFile = IO.of(&apos;/home/mostly-adequate/ch09.md&apos;);

const pureLog = function pureLog(str) { return new IO(() =&gt; { console.log(str); return str; }); };

const addToMailingList = function addToMailingList(email) { return IO.of([email]); };

const emailBlast = function emailBlast(list) { return IO.of(list.join(&apos;,&apos;)); };

const validateEmail = function validateEmail(x) {
  return /\S+@\S+\.\S+/.test(x)
    ? Either.of(x)
    : left(&apos;invalid email&apos;);
};


/* ---------- Chapter 10 ---------- */

const localStorage = { player1: albert, player2: theresa };

const game = curry(function game(p1, p2) { return `${p1.name} vs ${p2.name}`; });

const getFromCache = function getFromCache(x) { return new IO(() =&gt; localStorage[x]); };


/* ---------- Chapter 11 ---------- */

const findUserById = function findUserById(id) {
  switch (id) {
    case 1:
      return Task.of(Either.of(albert));

    case 2:
      return Task.of(Either.of(gary));

    case 3:
      return Task.of(Either.of(theresa));

    default:
      return Task.of(left(&apos;not found&apos;));
  }
};

const eitherToTask = namedAs(&apos;eitherToTask&apos;, either(Task.rejected, Task.of));


/* ---------- Chapter 12 ---------- */

const httpGet = function httpGet(route) { return Task.of(`json for ${route}`); };

const routes = new Map({
  &apos;/&apos;: &apos;/&apos;,
  &apos;/about&apos;: &apos;/about&apos;,
});

const validate = function validate(player) {
  return player.name
    ? Either.of(player)
    : left(&apos;must have name&apos;);
};

const readdir = function readdir(dir) {
  return Task.of([&apos;file1&apos;, &apos;file2&apos;, &apos;file3&apos;]);
};

const readfile = curry(function readfile(encoding, file) {
  return Task.of(`content of ${file} (${encoding})`);
});


/* ---------- Exports ---------- */

if (typeof module === &apos;object&apos;) {
  module.exports = {
    // Utils
    withSpyOn,

    // Essential FP helpers
    always,
    compose,
    curry,
    either,
    identity,
    inspect,
    left,
    liftA2,
    liftA3,
    maybe,
    nothing,
    reject,

    // Algebraic Data Structures
    Either,
    IO,
    Identity,
    Left,
    List,
    Map,
    Maybe,
    Right,
    Task,

    // Currified version of &apos;standard&apos; functions
    append,
    add,
    chain,
    concat,
    eq,
    filter,
    flip,
    forEach,
    head,
    intercalate,
    join,
    last,
    map,
    match,
    prop,
    reduce,
    safeHead,
    safeProp,
    sequence,
    sortBy,
    split,
    take,
    toLowerCase,
    toUpperCase,
    traverse,
    unsafePerformIO,

    // Chapter 04
    keepHighest,

    // Chapter 05
    cars,
    average,

    // Chapter 08
    albert,
    gary,
    theresa,
    yi,
    showWelcome,
    checkActive,
    save,
    validateUser,

    // Chapter 09
    getFile,
    pureLog,
    addToMailingList,
    emailBlast,
    validateEmail,

    // Chapter 10
    localStorage,
    getFromCache,
    game,

    // Chapter 11
    findUserById,
    eitherToTask,

    // Chapter 12
    httpGet,
    routes,
    validate,
    readdir,
    readfile,
  };
}</pre>
	

	<div class="buttons">
	    <a href="#" class="button size-2 action-submit">Submit</a>
	    <a href="#" class="button size-2 action-solution">Solution</a>
	</div>
</div>  </p>
<hr>
<p>As a reminder, the following functions are available in the exercise&apos;s context:</p>
<pre><code class="lang-hs"><span class="hljs-title">split</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span> -&gt; [<span class="hljs-type">String</span>]
<span class="hljs-title">intercalate</span> :: <span class="hljs-type">String</span> -&gt; [<span class="hljs-type">String</span>] -&gt; <span class="hljs-type">String</span>
</code></pre>
<p><div class="exercise">
	<div class="header">Exercise</div>
	<div class="alert alert-success">
	    <b>Correct!</b>
	</div>

	<div class="alert alert-danger error-message">
	    <b>False!</b>
	</div>

	<div class="message">
	  
Write the isomorphisms between String and [Char].
  

	</div>
	<div class="editor" style="height: 60px">// strToList :: String -&gt; [Char]
const strToList = undefined;

// listToStr :: [Char] -&gt; String
const listToStr = undefined;</div>

	<pre class="hidden code-solution">const strToList = split(&apos;&apos;);

const listToStr = intercalate(&apos;&apos;);</pre>
	<pre class="hidden code-validation">/* globals strToList, listToStr */

const sortLetters = compose(listToStr, sortBy(identity), strToList);

assert(
  sortLetters(&apos;sortme&apos;) === &apos;emorst&apos;,
  &apos;The function gives incorrect results&apos;,
);</pre>
	
	<pre class="hidden code-context">// NOTE We keep named function here to leverage this in the `compose` function,
// and later on in the validations scripts.

/* eslint-disable prefer-arrow-callback */


/* ---------- Internals ---------- */

function namedAs(value, fn) {
  Object.defineProperty(fn, &apos;name&apos;, { value });
  return fn;
}


// NOTE This file is loaded by gitbook&apos;s exercises plugin. When it does, there&apos;s an
// `assert` function available in the global scope.

/* eslint-disable no-undef, global-require */
if (typeof assert !== &apos;function&apos; &amp;&amp; typeof require === &apos;function&apos;) {
  global.assert = require(&apos;assert&apos;);
}

assert.arrayEqual = function assertArrayEqual(actual, expected, message = &apos;arrayEqual&apos;) {
  if (actual.length !== expected.length) {
    throw new Error(message);
  }

  for (let i = 0; i &lt; expected.length; i += 1) {
    if (expected[i] !== actual[i]) {
      throw new Error(message);
    }
  }
};
/* eslint-enable no-undef, global-require */


function inspect(x) {
  if (x &amp;&amp; typeof x.inspect === &apos;function&apos;) {
    return x.inspect();
  }

  function inspectFn(f) {
    return f.name ? f.name : f.toString();
  }

  function inspectTerm(t) {
    switch (typeof t) {
      case &apos;string&apos;:
        return `&apos;${t}&apos;`;
      case &apos;object&apos;: {
        const ts = Object.keys(t).map(k =&gt; [k, inspect(t[k])]);
        return `{${ts.map(kv =&gt; kv.join(&apos;: &apos;)).join(&apos;, &apos;)}}`;
      }
      default:
        return String(t);
    }
  }

  function inspectArgs(args) {
    return Array.isArray(args) ? `[${args.map(inspect).join(&apos;, &apos;)}]` : inspectTerm(args);
  }

  return (typeof x === &apos;function&apos;) ? inspectFn(x) : inspectArgs(x);
}


/* eslint-disable no-param-reassign */
function withSpyOn(prop, obj, fn) {
  const orig = obj[prop];
  let called = false;
  obj[prop] = function spy(...args) {
    called = true;
    return orig.call(this, ...args);
  };
  fn();
  obj[prop] = orig;
  return called;
}
/* eslint-enable no-param-reassign */


const typeMismatch = (src, got, fn) =&gt; `Type Mismatch in function &apos;${fn}&apos;

        ${fn} :: ${got}

      instead of

        ${fn} :: ${src}`;


const capitalize = s =&gt; `${s[0].toUpperCase()}${s.substring(1)}`;


const ordinal = (i) =&gt; {
  switch (i) {
    case 1:
      return &apos;1st&apos;;
    case 2:
      return &apos;2nd&apos;;
    case 3:
      return &apos;3rd&apos;;
    default:
      return `${i}th`; // NOTE won&apos;t get any much bigger ...
  }
};

const getType = (x) =&gt; {
  if (x === null) {
    return &apos;Null&apos;;
  }

  if (typeof x === &apos;undefined&apos;) {
    return &apos;()&apos;;
  }

  if (Array.isArray(x)) {
    return `[${x[0] ? getType(x[0]) : &apos;?&apos;}]`;
  }

  if (typeof x.getType === &apos;function&apos;) {
    return x.getType();
  }

  if (x.constructor &amp;&amp; x.constructor.name) {
    return x.constructor.name;
  }

  return capitalize(typeof x);
};


/* ---------- Essential FP Functions ---------- */

// NOTE A slightly pumped up version of `curry` which also keeps track of
// whether a function was called partially or with all its arguments at once.
// This is useful to provide insights during validation of exercises.
function curry(fn) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;function -&gt; ?&apos;, [getType(fn), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;curry&apos;),
  );

  const arity = fn.length;

  return namedAs(fn.name, function $curry(...args) {
    $curry.partially = this &amp;&amp; this.partially;

    if (args.length &lt; arity) {
      return namedAs(fn.name, $curry.bind({ partially: true }, ...args));
    }

    return fn.call(this || { partially: false }, ...args);
  });
}


// NOTE A slightly pumped up version of `compose` which also keeps track of the chain
// of callees. In the end, a function created with `compose` holds a `callees` variable
// with the list of all the callees&apos; names.
// This is useful to provide insights during validation of exercises
function compose(...fns) {
  const n = fns.length;

  return function $compose(...args) {
    $compose.callees = [];

    let $args = args;

    for (let i = n - 1; i &gt;= 0; i -= 1) {
      const fn = fns[i];

      assert(
        typeof fn === &apos;function&apos;,
        `Invalid Composition: ${ordinal(n - i)} element in a composition isn&apos;t a function`,
      );

      $compose.callees.push(fn.name);
      $args = [fn.call(null, ...$args)];
    }

    return $args[0];
  };
}


/* ---------- Algebraic Data Structures ---------- */

class Either {
  static of(x) {
    return new Right(x); // eslint-disable-line no-use-before-define
  }

  constructor(x) {
    this.$value = x;
  }
}


class Left extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return true;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return false;
  }

  ap() {
    return this;
  }

  chain() {
    return this;
  }

  inspect() {
    return `Left(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ${getType(this.$value)} ?)`;
  }

  join() {
    return this;
  }

  map() {
    return this;
  }

  sequence(of) {
    return of(this);
  }

  traverse(of, fn) {
    return of(this);
  }
}


class Right extends Either {
  get isLeft() { // eslint-disable-line class-methods-use-this
    return false;
  }

  get isRight() { // eslint-disable-line class-methods-use-this
    return true;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return fn(this.$value);
  }

  inspect() {
    return `Right(${inspect(this.$value)})`;
  }

  getType() {
    return `(Either ? ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Either.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    fn(this.$value).map(Either.of);
  }
}


class Identity {
  static of(x) {
    return new Identity(x);
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `Identity(${inspect(this.$value)})`;
  }

  getType() {
    return `(Identity ${getType(this.$value)})`;
  }

  join() {
    return this.$value;
  }

  map(fn) {
    return Identity.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return fn(this.$value).map(Identity.of);
  }
}

class IO {
  static of(x) {
    return new IO(() =&gt; x);
  }

  constructor(io) {
    assert(
      typeof io === &apos;function&apos;,
      &apos;invalid `io` operation given to IO constructor. Use `IO.of` if you want to lift a value in a default minimal IO context.&apos;,
    );

    this.unsafePerformIO = io;
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return `IO(${inspect(this.unsafePerformIO())})`;
  }

  getType() {
    return `(IO ${getType(this.unsafePerformIO())})`;
  }


  join() {
    return this.unsafePerformIO();
  }

  map(fn) {
    return new IO(compose(fn, this.unsafePerformIO));
  }
}


class Map {
  constructor(x) {
    assert(
      typeof x === &apos;object&apos; &amp;&amp; x !== null,
      &apos;tried to create `Map` with non object-like&apos;,
    );

    this.$value = x;
  }

  inspect() {
    return `Map(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[Object.keys(this.$value)[0]];

    return `(Map String ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  insert(k, v) {
    const singleton = {};
    singleton[k] = v;
    return new Map(Object.assign({}, this.$value, singleton));
  }

  reduce(fn, zero) {
    return this.reduceWithKeys((acc, _, k) =&gt; fn(acc, k), zero);
  }

  reduceWithKeys(fn, zero) {
    return Object.keys(this.$value)
      .reduce((acc, k) =&gt; fn(acc, this.$value[k], k), zero);
  }

  map(fn) {
    return new Map(this.reduceWithKeys((obj, v, k) =&gt; {
      obj[k] = fn(v); // eslint-disable-line no-param-reassign
      return obj;
    }, {}));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.reduceWithKeys(
      (f, a, k) =&gt; fn(a).map(b =&gt; m =&gt; m.insert(k, b)).ap(f),
      of(new Map({})),
    );
  }
}


class List {
  static of(x) {
    return new List([x]);
  }

  constructor(xs) {
    assert(
      Array.isArray(xs),
      &apos;tried to create `List` from non-array&apos;,
    );

    this.$value = xs;
  }

  concat(x) {
    return new List(this.$value.concat(x));
  }

  inspect() {
    return `List(${inspect(this.$value)})`;
  }

  getType() {
    const sample = this.$value[0];

    return `(List ${sample ? getType(sample) : &apos;?&apos;})`;
  }

  map(fn) {
    return new List(this.$value.map(fn));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.$value.reduce(
      (f, a) =&gt; fn(a).map(b =&gt; bs =&gt; bs.concat(b)).ap(f),
      of(new List([])),
    );
  }
}


class Maybe {
  static of(x) {
    return new Maybe(x);
  }

  get isNothing() {
    return this.$value === null || this.$value === undefined;
  }

  get isJust() {
    return !this.isNothing;
  }

  constructor(x) {
    this.$value = x;
  }

  ap(f) {
    return this.isNothing ? this : f.map(this.$value);
  }

  chain(fn) {
    return this.map(fn).join();
  }

  inspect() {
    return this.isNothing ? &apos;Nothing&apos; : `Just(${inspect(this.$value)})`;
  }

  getType() {
    return `(Maybe ${this.isJust ? getType(this.$value) : &apos;?&apos;})`;
  }

  join() {
    return this.isNothing ? this : this.$value;
  }

  map(fn) {
    return this.isNothing ? this : Maybe.of(fn(this.$value));
  }

  sequence(of) {
    return this.traverse(of, x =&gt; x);
  }

  traverse(of, fn) {
    return this.isNothing ? of(this) : fn(this.$value).map(Maybe.of);
  }
}


class Task {
  constructor(fork) {
    assert(
      typeof fork === &apos;function&apos;,
      &apos;invalid `fork` operation given to Task constructor. Use `Task.of` if you want to lift a value in a default minimal Task context.&apos;,
    );

    this.fork = fork;
  }

  static of(x) {
    return new Task((_, resolve) =&gt; resolve(x));
  }

  static rejected(x) {
    return new Task((reject, _) =&gt; reject(x));
  }

  ap(f) {
    return this.chain(fn =&gt; f.map(fn));
  }

  chain(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, x =&gt; fn(x).fork(reject, resolve)));
  }

  inspect() { // eslint-disable-line class-methods-use-this
    return &apos;Task(?)&apos;;
  }

  getType() { // eslint-disable-line class-methods-use-this
    return &apos;(Task ? ?)&apos;;
  }

  join() {
    return this.chain(x =&gt; x);
  }

  map(fn) {
    return new Task((reject, resolve) =&gt; this.fork(reject, compose(resolve, fn)));
  }
}

// In nodejs the existance of a class method named `inspect` will trigger a deprecation warning
// when passing an instance to `console.log`:
// `(node:3845) [DEP0079] DeprecationWarning: Custom inspection function on Objects via .inspect() is deprecated`
// The solution is to alias the existing inspect method with the special inspect symbol exported by node
if (typeof module !== &apos;undefined&apos; &amp;&amp; typeof this !== &apos;undefined&apos; &amp;&amp; this.module !== module) {
  const customInspect = require(&apos;util&apos;).inspect.custom;
  const assignCustomInspect = it =&gt; it.prototype[customInspect] = it.prototype.inspect;
  [Left, Right, Identity, IO, Map, List, Maybe, Task].forEach(assignCustomInspect);
}

const identity = function identity(x) { return x; };

const either = curry(function either(f, g, e) {
  if (e.isLeft) {
    return f(e.$value);
  }

  return g(e.$value);
});

const left = function left(x) { return new Left(x); };

const maybe = curry(function maybe(v, f, m) {
  if (m.isNothing) {
    return v;
  }

  return f(m.$value);
});

const nothing = Maybe.of(null);

const reject = function reject(x) { return Task.rejected(x); };

const chain = curry(function chain(fn, m) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m a&apos;, [getType(fn), getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;chain&apos;),
  );

  return m.chain(fn);
});

const join = function join(m) {
  assert(
    typeof m.chain === &apos;function&apos;,
    typeMismatch(&apos;Monad m =&gt; m (m a) -&gt; m a&apos;, [getType(m), &apos;m a&apos;].join(&apos; -&gt; &apos;), &apos;join&apos;),
  );

  return m.join();
};

const map = curry(function map(fn, f) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; typeof f.map === &apos;function&apos;,
    typeMismatch(&apos;Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b&apos;, [getType(fn), getType(f), &apos;f b&apos;].join(&apos; -&gt; &apos;), &apos;map&apos;),
  );

  return f.map(fn);
});

const sequence = curry(function sequence(of, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof x.sequence === &apos;function&apos;,
    typeMismatch(&apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; t (f a) -&gt; f (t a)&apos;, [getType(of), getType(x), &apos;f (t a)&apos;].join(&apos; -&gt; &apos;), &apos;sequence&apos;),
  );

  return x.sequence(of);
});

const traverse = curry(function traverse(of, fn, x) {
  assert(
    typeof of === &apos;function&apos; &amp;&amp; typeof fn === &apos;function&apos; &amp;&amp; typeof x.traverse === &apos;function&apos;,
    typeMismatch(
      &apos;(Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)&apos;,
      [getType(of), getType(fn), getType(x), &apos;f (t b)&apos;].join(&apos; -&gt; &apos;),
      &apos;traverse&apos;,
    ),
  );

  return x.traverse(of, fn);
});

const unsafePerformIO = function unsafePerformIO(io) {
  assert(
    io instanceof IO,
    typeMismatch(&apos;IO a&apos;, getType(io), &apos;unsafePerformIO&apos;),
  );

  return io.unsafePerformIO();
};

const liftA2 = curry(function liftA2(fn, a1, a2) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2);
});

const liftA3 = curry(function liftA3(fn, a1, a2, a3) {
  assert(
    typeof fn === &apos;function&apos;
      &amp;&amp; typeof a1.map === &apos;function&apos;
      &amp;&amp; typeof a2.ap === &apos;function&apos;
      &amp;&amp; typeof a3.ap === &apos;function&apos;,
    typeMismatch(&apos;Applicative f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d&apos;, [getType(fn), getType(a1), getType(a2)].join(&apos; -&gt; &apos;), &apos;liftA2&apos;),
  );

  return a1.map(fn).ap(a2).ap(a3);
});

const always = curry(function always(a, b) { return a; });


/* ---------- Pointfree Classic Utilities ---------- */

const append = curry(function append(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return b.concat(a);
});

const add = curry(function add(a, b) {
  assert(
    typeof a === &apos;number&apos; &amp;&amp; typeof b === &apos;number&apos;,
    typeMismatch(&apos;Number -&gt; Number -&gt; Number&apos;, [getType(a), getType(b), &apos;Number&apos;].join(&apos; -&gt; &apos;), &apos;add&apos;),
  );

  return a + b;
});

const concat = curry(function concat(a, b) {
  assert(
    typeof a === &apos;string&apos; &amp;&amp; typeof b === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; String&apos;, [getType(a), getType(b), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;concat&apos;),
  );

  return a.concat(b);
});

const eq = curry(function eq(a, b) {
  assert(
    getType(a) === getType(b),
    typeMismatch(&apos;a -&gt; a -&gt; Boolean&apos;, [getType(a), getType(b), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), eq),
  );

  return a === b;
});

const filter = curry(function filter(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; Boolean) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;filter&apos;),
  );

  return xs.filter(fn);
});

const flip = curry(function flip(fn, a, b) {
  assert(
    typeof fn === &apos;function&apos;,
    typeMismatch(&apos;(a -&gt; b) -&gt; (b -&gt; a)&apos;, [getType(fn), &apos;(b -&gt; a)&apos;].join(&apos; -&gt; &apos;), &apos;flip&apos;),
  );

  return fn(b, a);
});

const forEach = curry(function forEach(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(a -&gt; ()) -&gt; [a] -&gt; ()&apos;, [getType(fn), getType(xs), &apos;()&apos;].join(&apos; -&gt; &apos;), &apos;forEach&apos;),
  );

  xs.forEach(fn);
});

const intercalate = curry(function intercalate(str, xs) {
  assert(
    typeof str === &apos;string&apos; &amp;&amp; Array.isArray(xs) &amp;&amp; (xs.length === 0 || typeof xs[0] === &apos;string&apos;),
    typeMismatch(&apos;String -&gt; [String] -&gt; String&apos;, [getType(str), getType(xs), &apos;String&apos;].join(&apos; -&gt; &apos;), &apos;intercalate&apos;),
  );

  return xs.join(str);
});

const head = function head(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;head&apos;),
  );

  return xs[0];
};

const last = function last(xs) {
  assert(
    Array.isArray(xs) || typeof xs === &apos;string&apos;,
    typeMismatch(&apos;[a] -&gt; a&apos;, [getType(xs), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;last&apos;),
  );

  return xs[xs.length - 1];
};

const match = curry(function match(re, str) {
  assert(
    re instanceof RegExp &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;RegExp -&gt; String -&gt; Boolean&apos;, [getType(re), getType(str), &apos;Boolean&apos;].join(&apos; -&gt; &apos;), &apos;match&apos;),
  );

  return re.test(str);
});

const prop = curry(function prop(p, obj) {
  assert(
    typeof p === &apos;string&apos; &amp;&amp; typeof obj === &apos;object&apos; &amp;&amp; obj !== null,
    typeMismatch(&apos;String -&gt; Object -&gt; a&apos;, [getType(p), getType(obj), &apos;a&apos;].join(&apos; -&gt; &apos;), &apos;prop&apos;),
  );

  return obj[p];
});

const reduce = curry(function reduce(fn, zero, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;(b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b&apos;, [getType(fn), getType(zero), getType(xs), &apos;b&apos;].join(&apos; -&gt; &apos;), &apos;reduce&apos;),
  );

  return xs.reduce(
    function $reduceIterator($acc, $x) { return fn($acc, $x); },
    zero,
  );
});

const safeHead = namedAs(&apos;safeHead&apos;, compose(Maybe.of, head));

const safeProp = curry(function safeProp(p, obj) { return Maybe.of(prop(p, obj)); });

const sortBy = curry(function sortBy(fn, xs) {
  assert(
    typeof fn === &apos;function&apos; &amp;&amp; Array.isArray(xs),
    typeMismatch(&apos;Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]&apos;, [getType(fn), getType(xs), &apos;[a]&apos;].join(&apos; -&gt; &apos;), &apos;sortBy&apos;),
  );

  return xs.sort((a, b) =&gt; {
    if (fn(a) === fn(b)) {
      return 0;
    }

    return fn(a) &gt; fn(b) ? 1 : -1;
  });
});

const split = curry(function split(s, str) {
  assert(
    typeof s === &apos;string&apos; &amp;&amp; typeof str === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String -&gt; [String]&apos;, [getType(s), getType(str), &apos;[String]&apos;].join(&apos; -&gt; &apos;), &apos;split&apos;),
  );

  return str.split(s);
});

const take = curry(function take(n, xs) {
  assert(
    typeof n === &apos;number&apos; &amp;&amp; (Array.isArray(xs) || typeof xs === &apos;string&apos;),
    typeMismatch(&apos;Number -&gt; [a] -&gt; [a]&apos;, [getType(n), getType(xs), getType(xs)].join(&apos; -&gt; &apos;), &apos;take&apos;),
  );

  return xs.slice(0, n);
});

const toLowerCase = function toLowerCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toLowerCase();
};

const toUpperCase = function toUpperCase(s) {
  assert(
    typeof s === &apos;string&apos;,
    typeMismatch(&apos;String -&gt; String&apos;, [getType(s), &apos;?&apos;].join(&apos; -&gt; &apos;), &apos;toLowerCase&apos;),
  );

  return s.toUpperCase();
};


/* ---------- Chapter 4 ---------- */

const keepHighest = function keepHighest(x, y) {
  try {
    keepHighest.calledBy = keepHighest.caller;
  } catch (err) {
    // NOTE node.js runs in strict mode and prohibit the usage of &apos;.caller&apos;
    // There&apos;s a ugly hack to retrieve the caller from stack trace.
    const [, caller] = /at (\S+)/.exec(err.stack.split(&apos;\n&apos;)[2]);

    keepHighest.calledBy = namedAs(caller, () =&gt; {});
  }

  return x &gt;= y ? x : y;
};


/* ---------- Chapter 5 ---------- */

const cars = [{
  name: &apos;Ferrari FF&apos;,
  horsepower: 660,
  dollar_value: 700000,
  in_stock: true,
}, {
  name: &apos;Spyker C12 Zagato&apos;,
  horsepower: 650,
  dollar_value: 648000,
  in_stock: false,
}, {
  name: &apos;Jaguar XKR-S&apos;,
  horsepower: 550,
  dollar_value: 132000,
  in_stock: true,
}, {
  name: &apos;Audi R8&apos;,
  horsepower: 525,
  dollar_value: 114200,
  in_stock: false,
}, {
  name: &apos;Aston Martin One-77&apos;,
  horsepower: 750,
  dollar_value: 1850000,
  in_stock: true,
}, {
  name: &apos;Pagani Huayra&apos;,
  horsepower: 700,
  dollar_value: 1300000,
  in_stock: false,
}];

const average = function average(xs) {
  return xs.reduce(add, 0) / xs.length;
};


/* ---------- Chapter 8 ---------- */

const albert = {
  id: 1,
  active: true,
  name: &apos;Albert&apos;,
  address: {
    street: {
      number: 22,
      name: &apos;Walnut St&apos;,
    },
  },
};

const gary = {
  id: 2,
  active: false,
  name: &apos;Gary&apos;,
  address: {
    street: {
      number: 14,
    },
  },
};

const theresa = {
  id: 3,
  active: true,
  name: &apos;Theresa&apos;,
};

const yi = { id: 4, name: &apos;Yi&apos;, active: true };

const showWelcome = namedAs(&apos;showWelcome&apos;, compose(concat(&apos;Welcome &apos;), prop(&apos;name&apos;)));

const checkActive = function checkActive(user) {
  return user.active
    ? Either.of(user)
    : left(&apos;Your account is not active&apos;);
};

const save = function save(user) {
  return new IO(() =&gt; Object.assign({}, user, { saved: true }));
};

const validateUser = curry(function validateUser(validate, user) {
  return validate(user).map(_ =&gt; user); // eslint-disable-line no-unused-vars
});


/* ---------- Chapter 9 ---------- */

const getFile = IO.of(&apos;/home/mostly-adequate/ch09.md&apos;);

const pureLog = function pureLog(str) { return new IO(() =&gt; { console.log(str); return str; }); };

const addToMailingList = function addToMailingList(email) { return IO.of([email]); };

const emailBlast = function emailBlast(list) { return IO.of(list.join(&apos;,&apos;)); };

const validateEmail = function validateEmail(x) {
  return /\S+@\S+\.\S+/.test(x)
    ? Either.of(x)
    : left(&apos;invalid email&apos;);
};


/* ---------- Chapter 10 ---------- */

const localStorage = { player1: albert, player2: theresa };

const game = curry(function game(p1, p2) { return `${p1.name} vs ${p2.name}`; });

const getFromCache = function getFromCache(x) { return new IO(() =&gt; localStorage[x]); };


/* ---------- Chapter 11 ---------- */

const findUserById = function findUserById(id) {
  switch (id) {
    case 1:
      return Task.of(Either.of(albert));

    case 2:
      return Task.of(Either.of(gary));

    case 3:
      return Task.of(Either.of(theresa));

    default:
      return Task.of(left(&apos;not found&apos;));
  }
};

const eitherToTask = namedAs(&apos;eitherToTask&apos;, either(Task.rejected, Task.of));


/* ---------- Chapter 12 ---------- */

const httpGet = function httpGet(route) { return Task.of(`json for ${route}`); };

const routes = new Map({
  &apos;/&apos;: &apos;/&apos;,
  &apos;/about&apos;: &apos;/about&apos;,
});

const validate = function validate(player) {
  return player.name
    ? Either.of(player)
    : left(&apos;must have name&apos;);
};

const readdir = function readdir(dir) {
  return Task.of([&apos;file1&apos;, &apos;file2&apos;, &apos;file3&apos;]);
};

const readfile = curry(function readfile(encoding, file) {
  return Task.of(`content of ${file} (${encoding})`);
});


/* ---------- Exports ---------- */

if (typeof module === &apos;object&apos;) {
  module.exports = {
    // Utils
    withSpyOn,

    // Essential FP helpers
    always,
    compose,
    curry,
    either,
    identity,
    inspect,
    left,
    liftA2,
    liftA3,
    maybe,
    nothing,
    reject,

    // Algebraic Data Structures
    Either,
    IO,
    Identity,
    Left,
    List,
    Map,
    Maybe,
    Right,
    Task,

    // Currified version of &apos;standard&apos; functions
    append,
    add,
    chain,
    concat,
    eq,
    filter,
    flip,
    forEach,
    head,
    intercalate,
    join,
    last,
    map,
    match,
    prop,
    reduce,
    safeHead,
    safeProp,
    sequence,
    sortBy,
    split,
    take,
    toLowerCase,
    toUpperCase,
    traverse,
    unsafePerformIO,

    // Chapter 04
    keepHighest,

    // Chapter 05
    cars,
    average,

    // Chapter 08
    albert,
    gary,
    theresa,
    yi,
    showWelcome,
    checkActive,
    save,
    validateUser,

    // Chapter 09
    getFile,
    pureLog,
    addToMailingList,
    emailBlast,
    validateEmail,

    // Chapter 10
    localStorage,
    getFromCache,
    game,

    // Chapter 11
    findUserById,
    eitherToTask,

    // Chapter 12
    httpGet,
    routes,
    validate,
    readdir,
    readfile,
  };
}</pre>
	

	<div class="buttons">
	    <a href="#" class="button size-2 action-submit">Submit</a>
	    <a href="#" class="button size-2 action-solution">Solution</a>
	</div>
</div>  </p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="ch10.html#exercises" class="navigation navigation-prev " aria-label="Previous page: Exercises">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ch11.html#curse-this-nest" class="navigation navigation-next " aria-label="Next page: Curse This Nest">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Chapter 11: Transform Again, Naturally","level":"1.12","depth":1,"next":{"title":"Curse This Nest","level":"1.12.1","depth":2,"anchor":"#curse-this-nest","path":"ch11.md","ref":"ch11.md#curse-this-nest","articles":[]},"previous":{"title":"Exercises","level":"1.11.9","depth":2,"anchor":"#exercises","path":"ch10.md","ref":"ch10.md#exercises","articles":[]},"dir":"ltr"},"config":{"plugins":["exercises@git+https://github.com/MostlyAdequate/plugin-exercises.git","include-codeblock@3.1.2"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"exercises":{},"include-codeblock":{"check":false,"edit":false,"lang":"","fixlang":false,"template":"default","theme":"chrome","unindent":false},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"cover":"images/cover.png","title":"Professor Frisby's Mostly Adequate Guide to Functional Programming","gitbook":"3.2.2"},"file":{"path":"ch11.md","mtime":"2023-03-16T13:34:28.228Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2023-03-16T13:35:26.336Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook-plugin-exercises/jsrepl/jsrepl.js" id="jsrepl-script"></script>
    
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-exercises/ace/ace.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-exercises/ace/theme-tomorrow.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-exercises/ace/mode-javascript.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-exercises/exercises.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    


    </body>
</html>

